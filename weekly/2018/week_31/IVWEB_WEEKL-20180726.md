## 文章索引
1、 <a href="#1文章-为什么说react是ui的未来" >文章： 为什么说React是UI的未来</a><br/>
2、 <a href="#22018你需要知道的11个实用javascript库" >2018，你需要知道的11个实用JavaScript库</a><br/>
3、 <a href="#3视频演讲-基于深度学习的视频结构化实践" >视频演讲： 基于深度学习的视频结构化实践</a><br/>
4、 <a href="#4how-to-improve-test-coverage-for-your-android-app-using-mockito-and-espresso" >How To Improve Test Coverage For Your Android App Using Mockito And Espresso</a><br/>
5、 <a href="#5文章-为什么说flutter让移动开发变得更好" >文章： 为什么说Flutter让移动开发变得更好？</a><br/>
6、 <a href="#6文章-python自动化测试框架有哪些" >文章： Python自动化测试框架有哪些？</a><br/>
7、 <a href="#7视频演讲-umstor数字时代的分布式多协议统一存储实践" >视频演讲： UMStor：数字时代的分布式多协议统一存储实践</a><br/>
8、 <a href="#8文章-猫量子位和远距传动令人匪夷所思的量子计算世界第三部分" >文章： 猫、量子位和远距传动：令人匪夷所思的量子计算世界（第三部分）</a><br/>
9、 <a href="#9视频演讲-tencent-hub技术架构与devops落地实践揭秘" >视频演讲： Tencent Hub技术架构与DevOps落地实践揭秘</a><br/>
10、 <a href="#10微软发布azure-service-fabric-mesh公开预览版" >微软发布Azure Service Fabric Mesh公开预览版</a><br/>
11、 <a href="#11文章-关于go语言你可能会讨厌的五件事" >文章： 关于Go语言，你可能会讨厌的五件事</a><br/>
12、 <a href="#12为所有php-fpm容器构建单独的nginx-docker镜像" >为所有PHP-FPM容器构建单独的Nginx Docker镜像</a><br/>
13、 <a href="#13kotlin生态调查结果出炉超过6成的开发者用过kotlin了" >Kotlin生态调查结果出炉：超过6成的开发者用过Kotlin了</a><br/>
14、 <a href="#14bccon看当今互联网企业区块链idea的可行性" >BCCon：看当今互联网企业区块链idea的可行性</a><br/><h1 id="#title_0" >1、文章： 为什么说React是UI的未来</h1>
Jani Eväkallio
[http://www.infoq.com/cn/articles/the-present-future-of-user-interface-development?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/the-present-future-of-user-interface-development?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/the-present-future-of-user-interface-development/zh/smallimage/logo+%281%29-1532263686008.jpg"/><p>当前UI领域新技术层出不穷，更迭迅速。在众多技术中，本文的作者格外青睐React，认为React将会是开发者的终极选择。</p> <i>By Jani Eväkallio</i> <i> Translated by 安翔</i>
---------------
<h1 id="#title_1" >2、2018，你需要知道的11个实用JavaScript库</h1>
Jonathan Saring
[http://www.infoq.com/cn/news/2018/07/javascript-11library-mustknow?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2018/07/javascript-11library-mustknow?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>2018年需要了解的11个有用的JavaScript库。</p> <i>By Jonathan Saring</i> <i> Translated by 无明</i>
---------------
<h1 id="#title_2" >3、视频演讲： 基于深度学习的视频结构化实践</h1>
姚唐仁
[http://www.infoq.com/cn/presentations/video-structured-practice-based-on-deep-learning?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/video-structured-practice-based-on-deep-learning?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/presentations/video-structured-practice-based-on-deep-learning/zh/mediumimage/yaotangren270-1531535531842.jpg"/><p>仅低效、成本高，信息内容丢失也非常严重。七牛云作为互联网行业富媒体处理的领先者，结合最新的深度学习人工智能和分布式云平台技术在此领域进行了创新。通过对视频内容进行多维度智能分析与识别，可以直接结构化输出相关的标签，对图片、视频的内容进行结构化描述。同时结合大数据检索平台，可以让用户以低成本的方式对业务带来增值，加快业务创新。</p> <i>By 姚唐仁</i>
---------------
<h1 id="#title_3" >4、How To Improve Test Coverage For Your Android App Using Mockito And Espresso</h1>
Vivek Maskara
[https://www.smashingmagazine.com/2018/07/improving-test-coverage-android-app-mockito-espresso/](https://www.smashingmagazine.com/2018/07/improving-test-coverage-android-app-mockito-espresso/)
<html>
            <head>
              <meta charset="utf-8">
              <link rel="canonical" href="https://www.smashingmagazine.com/2018/07/improving-test-coverage-android-app-mockito-espresso/" />
              <title>How To Improve Test Coverage For Your Android App Using Mockito And Espresso</title>
            </head>
            <body>
              <article>
                <header>
                  <h1>How To Improve Test Coverage For Your Android App Using Mockito And Espresso</h1>
                  
                    
                    <address>Vivek Maskara</address>
                  
                  <time datetime="2018-07-25T14:00:04&#43;02:00" class="op-published">2018-07-25T14:00:04+02:00</time>
                  <time datetime="2018-07-25T17:27:43&#43;00:00" class="op-modified">2018-07-25T17:27:43+00:00</time>
                </header>
                

<p>In app development, a variety of use cases and interactions come up as one iterates the code. The app might need to fetch data from a server, interact with the device&rsquo;s sensors, access local storage or render complex user interfaces.</p>

<p>The important thing to consider while writing tests is the units of responsibility that emerge as you design the new feature. The unit test should cover all possible interactions with the unit, including standard interactions and exceptional scenarios.</p>

<p>In this article, we will cover the fundamentals of testing and frameworks such as Mockito and Espresso, which developers can use to write unit tests. I will also briefly discuss how to write testable code. I’ll also explain how to get started with local and instrumented tests in Android.</p>

<p><strong>Recommended reading</strong>: <em></em></p>

<h3 id="fundamentals-of-testing">Fundamentals Of Testing</h3>

<p>A typical unit test contains three phases.</p>

<ol>
<li>First, the unit test initializes a small piece of an application it wants to test.</li>
<li>Then, it applies some stimulus to the system under test, usually by calling a method on it.</li>
<li>Finally, it observes the resulting behavior.</li>
</ol>

<p>If the observed behavior is consistent with the expectations, the unit test passes; otherwise, it fails, indicating that there is a problem somewhere in the system under test. These three unit test phases are also known as <strong>a</strong><strong>rrange</strong>, <strong>a</strong><strong>ct</strong> and <strong>a</strong><strong>ssert</strong>, or simply AAA. The app should ideally include three categories of tests: small, medium and large.</p>

<ul>
<li><strong>Small tests</strong> comprise unit tests that mock every major component and run quickly in isolation.</li>
<li><strong>Medium tests</strong> are integration tests that integrate several components and run on emulators or real devices.</li>
<li><strong>Large tests</strong> are integration and UI tests that run by completing a UI workflow and ensure that the key end-user tasks work as expected.</li>
</ul>

<p><strong>Note:</strong> <em>An instrumentation test is a type of integration test. These are tests that run on an Android device or emulator. These tests have access to instrumentation information, such as the context of the app under test. Use this approach to run unit tests that have Android dependencies that mock objects cannot easily satisfy.</em></p>



<aside class="product-panel product-panel__tilted product-panel--book" data-audience="non-subscriber">
    <div class="container product-panel--book__container">
      <div class="panel__description panel__description--book">
    <p>Nope, we can't do any magic tricks, but we have articles,  get a seasoned selection of magic front-end tricks — e.g. <strong>live designing sessions</strong> and perf audits, too. <em>Just sayin'</em>! ;-)</p>

      <a href="http://smashed.by/perfpanelmembership" class="btn btn--green btn--large">
        Explore Smashing Wizardry&nbsp;→
      </a>
      </div>
      <div class="panel__image panel__image--book">
        <a href="http://smashed.by/perfpanelmembership" class="books__book__image">
        <div class="books__book__img">
          <img src="https://www.smashingmagazine.com/images/smashing-cat/cat-wizard.svg" alt="Smashing Cat, just preparing to do some magic stuff." width="310" height="400">
        </div>
      </a>
      </div>
    </div>
  </aside>




<p>Writing small tests allows you to address failures quickly, but it’s difficult to gain confidence that a passing test will allow your app to work. It’s important to have tests from all categories in the app, although the proportion of each category can vary from app to app. A good unit test should be <strong>easy to write</strong>, <strong>readable</strong>, <strong>reliable</strong> and <strong>fast</strong>.</p>

<p>Here’s a brief introduction to Mockito and Espresso, which make testing Android apps easier.</p>

<h4 id="mockito">Mockito</h4>

<p>There are various mocking frameworks, but the most popular of them all is :</p>

<blockquote>Mockito is a mocking framework that tastes really good. It lets you write beautiful tests with a clean & simple API. Mockito doesn’t give you hangover because the tests are very readable and they produce clean verification errors.</blockquote>

<p>Its fluent API separates pre-test preparation from post-test validation. Should the test fail, Mockito makes it clear to see where our expectations differ from reality! The library has everything you need to write complete tests.</p>

<h4 id="espresso">Espresso</h4>

<p>Espresso helps you write concise, beautiful and reliable Android UI tests.</p>

<p>The code snippet below shows an example of an Espresso test. We will take up the same example later in this tutorial when we talk in detail about instrumentation tests.</p>

<pre class="break-out"><code class="language-javascript">@Test
public void setUserName() {
    onView(withId(R.id.name_field)).perform(typeText("Vivek Maskara"));
    onView(withId(R.id.set_user_name)).perform(click());
    onView(withText("Hello Vivek Maskara!")).check(matches(isDisplayed()));
}
</code></pre>

<p>Espresso tests state expectations, interactions and assertions clearly, without the distraction of boilerplate content, custom infrastructure or messy implementation details getting in the way. Whenever your test invokes <code>onView()</code>, Espresso waits to perform the corresponding UI action or assertion until the synchronization conditions are met, meaning:</p>

<ul>
<li>the message queue is empty,</li>
<li>no instances of <code>AsyncTask</code> are currently executing a task,</li>
<li>the idling resources are idle.</li>
</ul>

<p>These checks ensure that the test results are reliable.</p>

<h3 id="writing-testable-code">Writing Testable Code</h3>

<p>Unit testing Android apps is difficult and sometimes impossible. A good design, and only a good design, can make unit testing easier. Here are some of the concepts that are important for writing testable code.</p>

<h4 id="avoid-mixing-object-graph-construction-with-application-logic">Avoid Mixing Object Graph Construction With Application Logic</h4>

<p>In a test, you want to instantiate the class under test and apply some stimulus to the class and assert that the expected behavior was observed. Make sure that the class under test doesn&rsquo;t instantiate other objects and that those objects do not instantiate more objects and so on. In order to have a testable code base, your application should have two kinds of classes:</p>

<ul>
<li>The factories, which are full of the &ldquo;new&rdquo; operators and which are responsible for building the object graph of your application;</li>
<li>The application logic classes, which are devoid of the &ldquo;new&rdquo; operator and which are responsible for doing the work.</li>
</ul>

<h4 id="constructors-should-not-do-any-work">Constructors Should Not Do Any Work</h4>

<p>The most common operation you will do in tests is the instantiation of object graphs. So, make it easy on yourself, and make the constructors do no work other than assigning all of the dependencies into the fields. Doing work in the constructor not only will affect the direct tests of the class, but will also affect related tests that try to instantiate your class indirectly.</p>

<h4 id="avoid-static-methods-wherever-possible">Avoid Static Methods Wherever Possible</h4>

<p>The key to testing is the presence of places where you can divert the normal execution flow. Seams are needed so that you can isolate the unit of test. If you build an application with nothing but static methods, you will have a procedural application. How much a static method will hurt from a testing point of view depends on where it is in your application call graph. A leaf method such as <code>Math.abs()</code> is not a problem because the execution call graph ends there. But if you pick a method in a core of your application logic, then everything behind the method will become hard to test, because there is no way to insert test doubles</p>

<h4 id="avoid-mixing-of-concerns">Avoid Mixing Of Concerns</h4>

<p>A class should be responsible for dealing with just one entity. Inside a class, a method should be responsible for doing just one thing. For example, <code>BusinessService</code> should be responsible just for talking to a <code>Business</code> and not <code>BusinessReceipts</code>. Moreover, a method in <code>BusinessService</code> could be <code>getBusinessProfile</code>, but a method such as <code>createAndGetBusinessProfile</code> would not be ideal for testing.  must be followed for good design:</p>

<ul>
<li><strong>S</strong>: single-responsibility principle;</li>
<li><strong>O</strong>: open-closed principle;</li>
<li><strong>L</strong>: Liskov substitution principle;</li>
<li><strong>I</strong>: interface segregation principle;</li>
<li><strong>D</strong>: dependency inversion principle.</li>
</ul>

<p>In the next few sections, we will be using examples from a really simple application that I built for this tutorial. The app has an <code>EditText</code> that takes a user name as input and displays the name in a <code>TextView</code> upon the click of a button. Feel free to take the complete  for the project from GitHub. Here’s a screenshot of the app:</p>











<figure >
	<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2ff53d66-273d-452a-88fe-7e434ba87ff9/mockito-espresso-testing-example.png">
		<img
			srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2ff53d66-273d-452a-88fe-7e434ba87ff9/mockito-espresso-testing-example.png 400w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2ff53d66-273d-452a-88fe-7e434ba87ff9/mockito-espresso-testing-example.png 800w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2ff53d66-273d-452a-88fe-7e434ba87ff9/mockito-espresso-testing-example.png 1200w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2ff53d66-273d-452a-88fe-7e434ba87ff9/mockito-espresso-testing-example.png 1600w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2ff53d66-273d-452a-88fe-7e434ba87ff9/mockito-espresso-testing-example.png 2000w"
			src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2ff53d66-273d-452a-88fe-7e434ba87ff9/mockito-espresso-testing-example.png"
			sizes="100vw"
			alt="Testing example"
		/>
	</a>

	
		<figcaption class="op-vertical-bottom">
			
		</figcaption>
	
</figure>


<h3 id="writing-local-unit-tests">Writing Local Unit Tests</h3>

<p>Unit tests can be run locally on your development machine without a device or an emulator. This testing approach is efficient because it avoids the overhead of having to load the target app and unit test code onto a physical device or emulator every time your test is run. In addition to Mockito, you will also need to configure the testing dependencies for your project to use the standard APIs provided by the JUnit 4 framework.</p>

<h4 id="setting-up-the-development-environment">Setting Up The Development Environment</h4>

<p>Start by adding a dependency on JUnit4 in your project. The dependency is of the type <code>testImplementation</code>, which means that the dependencies are only required to compile the test source of the project.</p>

<pre><code class="language-javascript">testImplementation 'junit:junit:4.12'
</code></pre>

<p>We will also need the Mockito library to make interaction with Android dependencies easier.</p>

<pre class="break-out"><code class="language-javascript">testImplementation "org.mockito:mockito-core:$MOCKITO_VERSION"</code></pre>

<p>Make sure to sync the project after adding the dependency. Android Studio should have created the folder structure for unit tests by default. If not, make sure the following directory structure exists:</p>

<pre class="break-out"><code class="language-html">&lt;Project Dir&gt;/app/src/test/java/com/maskaravivek/testingExamples
</code></pre>

<div class="sponsors__wide-place"></div>




<h4 id="creating-your-first-unit-test">Creating Your First Unit Test</h4>

<p>Suppose you want to test the <code>displayUserName</code> function in the <code>UserService</code>. For the sake of simplicity, the function simply formats the input and returns it back. In a real-world application, it could make a network call to fetch the user profile and return the user’s name.</p>

<pre class="break-out"><code class="language-javascript">@Singleton
class UserService @Inject
constructor(private var context: Context) {
    
    fun displayUserName(name: String): String {
        val userNameFormat = context.getString(R.string.display_user_name)
        return String.format(Locale.ENGLISH, userNameFormat, name)
    }
}
</code></pre>

<p>We will start by creating a <code>UserServiceTest</code> class in our test directory. The <code>UserService</code> class uses <code>Context</code>, which needs to be mocked for the purpose of testing. Mockito provides a <code>@Mock</code> notation for mocking objects, which can be used as follows:</p>

<pre><code class="language-javascript">@Mock internal var context: Context? = null
</code></pre>

<p>Similarly, you’ll need to mock all dependencies required to construct the instance of the <code>UserService</code> class. Before your test, you’ll need to initialize these mocks and inject them into the <code>UserService</code> class.</p>

<ul>
<li><code>@InjectMock</code> creates an instance of the class and injects the mocks that are marked with the annotations <code>@Mock</code> into it.</li>
<li><code>MockitoAnnotations.initMocks(this);</code> initializes those fields annotated with Mockito annotations.</li>
</ul>

<p>Here&rsquo;s how it can be done:</p>

<pre class="break-out"><code class="language-javascript">class UserServiceTest {
    
    @Mock internal var context: Context? = null
    @InjectMocks internal var userService: UserService? = null
    
    @Before
    fun setup() {
        MockitoAnnotations.initMocks(this)
    }
}
</code></pre>

<p>Now you are done setting up your test class. Let&rsquo;s add a test to this class that verifies the functionality of the <code>displayUserName</code> function. Here&rsquo;s what the test looks like:</p>

<pre class="break-out"><code class="language-javascript">@Test
fun displayUserName() {
    doReturn("Hello %s!").`when`(context)!!.getString(any(Int::class.java))
    val displayUserName = userService!!.displayUserName("Test")
    assertEquals(displayUserName, "Hello Test!")
}
</code></pre>

<p>The test uses a <code>doReturn().when()</code> statement to provide a response when a <code>context.getString()</code> is invoked. For any input integer, it will return the same result, <code>&quot;Hello %s!&quot;</code>. We could have been more specific by making it return this response only for a particular string resource ID, but for the sake of simplicity, we are returning the same response to any input.
Finally, here&rsquo;s what the test class looks like:</p>

<pre class="break-out"><code class="language-javascript">class UserServiceTest {
    @Mock internal var context: Context? = null
    @InjectMocks internal var userService: UserService? = null
    @Before
    fun setup() {
        MockitoAnnotations.initMocks(this)
    }
     
    @Test
    fun displayUserName() {
        doReturn("Hello %s!").`when`(context)!!.getString(any(Int::class.java))
        val displayUserName = userService!!.displayUserName("Test")
        assertEquals(displayUserName, "Hello Test!")
    }
}
</code></pre>

<h4 id="running-your-unit-tests">Running Your Unit Tests</h4>

<p>In order to run the unit tests, you need to make sure that Gradle is synchronized. In order to run a test, click on the green play icon in the IDE.</p>











<figure class="article__image break-out">
	<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/080d9ba0-59a0-4f88-b595-ae198005901c/mockito-espresso-ide-green-icon.png">
		<img
			srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/080d9ba0-59a0-4f88-b595-ae198005901c/mockito-espresso-ide-green-icon.png 400w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/080d9ba0-59a0-4f88-b595-ae198005901c/mockito-espresso-ide-green-icon.png 800w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/080d9ba0-59a0-4f88-b595-ae198005901c/mockito-espresso-ide-green-icon.png 1200w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/080d9ba0-59a0-4f88-b595-ae198005901c/mockito-espresso-ide-green-icon.png 1600w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/080d9ba0-59a0-4f88-b595-ae198005901c/mockito-espresso-ide-green-icon.png 2000w"
			src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/080d9ba0-59a0-4f88-b595-ae198005901c/mockito-espresso-ide-green-icon.png"
			sizes="100vw"
			alt=""
		/>
	</a>

	
		<figcaption class="op-vertical-bottom">
			making sure that Gradle is synchronized
		</figcaption>
	
</figure>


<p>When the unit tests are run, successfully or otherwise, you should see this in the “Run” menu at the bottom of the screen:</p>

<figure></figcaption></figure>

<p>You are done with your first unit test!</p>

<h3 id="writing-instrumentation-tests">Writing Instrumentation Tests</h3>

<p>Instrumentation tests are most suited for checking values of UI components when an activity is run. For instance, in the example above, we want to make sure that the <code>TextView</code> shows the correct user name after the <code>Button</code> is clicked. They run on physical devices and emulators and can take advantage of the Android framework APIs and supporting APIs, such as the Android Testing Support Library.
We&rsquo;ll use Espresso to take actions on the main thread, such as button clicks and text changes.</p>

<h4 id="setting-up-the-development-environment-1">Setting Up The Development Environment</h4>

<p>Add a dependency on Espresso:</p>

<pre class="break-out"><code class="language-javascript">androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
</code></pre>

<p>Instrumentation tests are created in an <code>androidTest</code> folder.</p>

<pre class="break-out"><code class="language-javascript">&lt;Project Dir&gt;/app/src/androidTest/java/com/maskaravivek/testingExamples
</code></pre>

<p>If you want to test a simple activity, create your test class in the same package as your activity.</p>

<h4 id="creating-your-first-instrumentation-test">Creating Your First Instrumentation Test</h4>

<p>Let’s start by creating a simple activity that takes a name as input and, on the click of a button, displays the user name. The code for the activity above is quite simple:</p>

<pre class="break-out"><code class="language-javascript">class MainActivity : AppCompatActivity() {
    
    var button: Button? = null
    var userNameField: EditText? = null
    var displayUserName: TextView? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        AndroidInjection.inject(this)
        setContentView(R.layout.activity_main)
        initViews()
    }
    
    private fun initViews() {
        button = this.findViewById(R.id.set_user_name)
        userNameField = this.findViewById(R.id.name_field)
        displayUserName = this.findViewById(R.id.display_user_name)
    
        this.button!!.setOnClickListener({
            displayUserName!!.text = "Hello ${userNameField!!.text}!"
        })
    }
}
</code></pre>

<p>To create a test for the <code>MainActivity</code>, we will start by creating a <code>MainActivityTest</code> class under the <code>androidTest</code> directory. Add the <code>AndroidJUnit4</code> annotation to the class to indicate that the tests in this class will use the default Android test runner class.</p>

<pre><code class="language-javascript">@RunWith(AndroidJUnit4::class)
class MainActivityTest {}
</code></pre>

<p>Next, add an <code>ActivityTestRule</code> to the class. This rule provides functional testing of a single activity. For the duration of the test, you will be able to manipulate your activity directly using the reference obtained from <code>getActivity()</code>.</p>

<pre><code class="language-javascript">@Rule @JvmField var activityActivityTestRule = ActivityTestRule(MainActivity::class.java)
</code></pre>

<p>Now that you are done setting up the test class, let’s add a test that verifies that the user name is displayed by clicking the “Set User Name” button.</p>

<pre class="break-out"><code class="language-javascript">@Test
fun setUserName() {
    onView(withId(R.id.name_field)).perform(typeText("Vivek Maskara"))
    onView(withId(R.id.set_user_name)).perform(click())
    onView(withText("Hello Vivek Maskara!")).check(matches(isDisplayed()))
}
</code></pre>

<p>The test above is quite simple to follow. It first simulates some text being typed in the <code>EditText</code>, performs the click action on the button, and then checks whether the correct text is displayed in the <code>TextView</code>.</p>

<p>The final test class looks like this:</p>

<pre class="break-out"><code class="language-javascript">@RunWith(AndroidJUnit4::class)
class MainActivityTest {
    
    @Rule @JvmField var activityActivityTestRule = ActivityTestRule(MainActivity::class.java)
    
    @Test
    fun setUserName() {
        onView(withId(R.id.name_field)).perform(typeText("Vivek Maskara"))
        onView(withId(R.id.set_user_name)).perform(click())
        onView(withText("Hello Vivek Maskara!")).check(matches(isDisplayed()))
    }
}
</code></pre>

<h4 id="running-your-instrumentation-tests">Running Your Instrumentation Tests</h4>

<p>Just like for unit tests, click on the green play button in the IDE to run the test.</p>











<figure class="article__image break-out">
	<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a17ec68e-9d06-4ca5-abb5-4cd2f85f8f47/mockito-espresso-ide-green-play-button.png">
		<img
			srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a17ec68e-9d06-4ca5-abb5-4cd2f85f8f47/mockito-espresso-ide-green-play-button.png 400w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a17ec68e-9d06-4ca5-abb5-4cd2f85f8f47/mockito-espresso-ide-green-play-button.png 800w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a17ec68e-9d06-4ca5-abb5-4cd2f85f8f47/mockito-espresso-ide-green-play-button.png 1200w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a17ec68e-9d06-4ca5-abb5-4cd2f85f8f47/mockito-espresso-ide-green-play-button.png 1600w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a17ec68e-9d06-4ca5-abb5-4cd2f85f8f47/mockito-espresso-ide-green-play-button.png 2000w"
			src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/a17ec68e-9d06-4ca5-abb5-4cd2f85f8f47/mockito-espresso-ide-green-play-button.png"
			sizes="100vw"
			alt="clicking on the green play button in IDE to run the test"
		/>
	</a>

	
		<figcaption class="op-vertical-bottom">
			
		</figcaption>
	
</figure>


<p>Upon a click of the play button, the test version of the app will be installed on the emulator or device, and the test will run automatically on it.</p>











<figure class="article__image break-out">
	<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png">
		<img
			srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png 400w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png 800w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png 1200w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png 1600w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png 2000w"
			src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png"
			sizes="100vw"
			alt=""
		/>
	</a>

	
		<figcaption class="op-vertical-bottom">
			
		</figcaption>
	
</figure>


<h3 id="intrumentation-testing-using-dagger-mockito-and-espresso">Intrumentation Testing Using Dagger, Mockito, And Espresso</h3>

<p>Espresso is one of the most popular UI testing frameworks, with good documentation and community support. Mockito ensures that objects perform the actions that are expected of them. Mockito also works well with dependency-injection libraries such as Dagger. Mocking the dependencies allows us to test a scenario in isolation.
Until now, our <code>MainActivity</code> hasn&rsquo;t used any dependency injection, and, as a result, we were able to write our UI test very easily. To make things a bit more interesting, let’s inject <code>UserService</code> in the <code>MainActivity</code> and use it to get the text to be displayed.</p>

<pre class="break-out"><code class="language-javascript">class MainActivity : AppCompatActivity() {
    
    var button: Button? = null
    var userNameField: EditText? = null
    var displayUserName: TextView? = null
    
    @Inject lateinit var userService: UserService
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        AndroidInjection.inject(this)
        setContentView(R.layout.activity_main)
        initViews()
    }
    
    private fun initViews() {
        button = this.findViewById(R.id.set_user_name)
        userNameField = this.findViewById(R.id.name_field)
        displayUserName = this.findViewById(R.id.display_user_name)
    
        this.button!!.setOnClickListener({
            displayUserName!!.text = userService.displayUserName(userNameField!!.text.toString())
        })
    }
}
</code></pre>

<p>With Dagger in the picture, we will have to set up a few things before we write instrumentation tests.
Imagine that the <code>displayUserName</code> function internally uses some API to fetch the details of the user. There should not be a situation in which a test does not pass due to a server fault. To avoid such a situation, we can use the dependency-injection framework Dagger and, for networking, Retrofit.</p>

<div class="sponsors__wide-place"></div>




<h4 id="setting-up-dagger-in-the-application">Setting Up Dagger In The Application</h4>

<p>We will quickly set up the basic modules and components required for Dagger. If you are not
familiar with Dagger, check out  on it.  We will start adding dependencies for using Dagger in the <code>build.gradle</code> file.</p>

<pre class="break-out"><code class="language-javascript">implementation "com.google.dagger:dagger-android:$DAGGER_VERSION"
implementation "com.google.dagger:dagger-android-support:$DAGGER_VERSION"
implementation "com.google.dagger:dagger:$DAGGER_VERSION"
kapt "com.google.dagger:dagger-compiler:$DAGGER_VERSION"
kapt "com.google.dagger:dagger-android-processor:$DAGGER_VERSION"
</code></pre>

<p>Create a component in the <code>Application</code> class, and add the necessary modules that will be used in our project. We need to inject dependencies in the <code>MainActivity</code> of our app. We will add a <code>@Module</code> for injecting in the activity.</p>

<pre class="break-out"><code class="language-javascript">@Module
abstract class ActivityBuilder {
    @ContributesAndroidInjector
    internal abstract fun bindMainActivity(): MainActivity
}
</code></pre>

<p>The <code>AppModule</code> class will provide the various dependencies required by the application. For our example, it will just provide an instance of <code>Context</code> and <code>UserService</code>.</p>

<pre class="break-out"><code class="language-javascript">@Module
open class AppModule(val application: Application) {
    @Provides
    @Singleton
    internal open fun provideContext(): Context {
        return application
    }
    
    @Provides
    @Singleton
    internal open fun provideUserService(context: Context): UserService {
        return UserService(context)
    }
}
</code></pre>    

<p>The <code>AppComponent</code> class lets you build the object graph for the application.</p>

<pre class="break-out"><code class="language-javascript">@Singleton
@Component(modules = [(AndroidSupportInjectionModule::class), (AppModule::class), (ActivityBuilder::class)])
interface AppComponent {
    
    @Component.Builder
    interface Builder {
        fun appModule(appModule: AppModule): Builder
        fun build(): AppComponent
    }
    
    fun inject(application: ExamplesApplication)
}
</code></pre>

<p>Create a method that returns the already built component, and then inject this component into <code>onCreate()</code>.</p>

<pre class="break-out"><code class="language-javascript">open class ExamplesApplication : Application(), HasActivityInjector {
    @Inject lateinit var dispatchingActivityInjector: DispatchingAndroidInjector&lt;Activity&gt;
    
    override fun onCreate() {
        super.onCreate()
        initAppComponent().inject(this)
    }
    
    open fun initAppComponent(): AppComponent {
        return DaggerAppComponent
            .builder()
            .appModule(AppModule(this))
            .build()
    }
    
    override fun activityInjector(): DispatchingAndroidInjector&lt;Activity&gt;? {
        return dispatchingActivityInjector
    }
}
</code></pre>

<h4 id="setting-up-dagger-in-the-test-application">Setting Up Dagger In The Test Application</h4>

<p>In order to mock responses from the server, we need to create a new <code>Application</code> class that extends the class above.</p>

<pre class="break-out"><code class="language-javascript">class TestExamplesApplication : ExamplesApplication() {
    
    override fun initAppComponent(): AppComponent {
        return DaggerAppComponent.builder()
            .appModule(MockApplicationModule(this))
            .build()
    }
    
    @Module
    private inner class MockApplicationModule internal constructor(application: Application) : AppModule(application) {
        override fun provideUserService(context: Context): UserService {
            val mock = Mockito.mock(UserService::class.java)
            `when`(mock!!.displayUserName("Test")).thenReturn("Hello Test!")
            return mock
        }
    }
}
</code></pre>

<p>As you can see in the example above, we’ve used Mockito to mock <code>UserService</code> and assume the results. We still need a new runner that will point to the new application class with the overwritten data.</p>

<pre class="break-out"><code class="language-javascript">class MockTestRunner : AndroidJUnitRunner() {
    
    override fun onCreate(arguments: Bundle) {
        StrictMode.setThreadPolicy(StrictMode.ThreadPolicy.Builder().permitAll().build())
        super.onCreate(arguments)
    }
    
    @Throws(InstantiationException::class, IllegalAccessException::class, ClassNotFoundException::class)
    override fun newApplication(cl: ClassLoader, className: String, context: Context): Application {
        return super.newApplication(cl, TestExamplesApplication::class.java.name, context)
    }
}
</code></pre>

<p>Next, you need to update the <code>build.gradle</code> file to use the <code>MockTestRunner</code>.</p>

<pre><code class="language-javascript">android {
    ...
    
    defaultConfig {
        ...
        testInstrumentationRunner ".MockTestRunner"
    }
}
</code></pre>

<h4 id="running-the-test">Running The Test</h4>

<p>All tests with the new <code>TestExamplesApplication</code> and <code>MockTestRunner</code> should be added at <code>androidTest</code> package. This implementation makes the tests fully independent from the server and gives us the ability to manipulate responses.
With the setup above in place, our test class won&rsquo;t change at all. When the test is run, the app will use <code>TestExamplesApplication</code> instead of <code>ExamplesApplication</code>, and, thus, a mocked instance of <code>UserService</code> will be used.</p>

<pre class="break-out"><code class="language-javascript">@RunWith(AndroidJUnit4::class)
class MainActivityTest {
    @Rule @JvmField var activityActivityTestRule = ActivityTestRule(MainActivity::class.java)
    
    @Test
    fun setUserName() {
        onView(withId(R.id.name_field)).perform(typeText("Test"))
        onView(withId(R.id.set_user_name)).perform(click())
        onView(withText("Hello Test!")).check(matches(isDisplayed()))
    }
}
</code></pre>

<p>The test will run successfully when you click on the green play button in the IDE.</p>











<figure class="article__image break-out">
	<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png">
		<img
			srcset="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png 400w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png 800w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1200/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png 1200w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_1600/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png 1600w,
			        https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png 2000w"
			src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_400/https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/875a391d-47f2-49b3-88c7-824356d4bae2/mockito-espresso-successful-test-run-ide.png"
			sizes="100vw"
			alt="successfully setting up Dagger and run tests using Espresso and Mockito"
		/>
	</a>

	
		<figcaption class="op-vertical-bottom">
			
		</figcaption>
	
</figure>


<p>That’s it! You have successfully set up Dagger and run tests using Espresso and Mockito.</p>

<h3 id="conclusion">Conclusion</h3>

<p>We’ve highlighted that the most important aspect of improving code coverage is to write testable code. Frameworks such as Espresso and Mockito provide easy-to-use APIs that make writing tests for various scenarios easier. Tests should be run in isolation, and mocking the dependencies gives us an opportunity to ensure that objects perform the actions that are expected of them.</p>

<p>A variety of Android testing tools are available, and, as the ecosystem matures, the process of setting up a testable environment and writing tests will become easier.</p>

<p>Writing unit tests requires some discipline, concentration and extra effort. By creating and running unit tests against your code, you can easily verify that the logic of individual units is correct. Running unit tests after every build helps you to quickly catch and fix software regressions introduced by code changes to your app. Google’s testing blog discusses the 
The complete  for the examples used in this article is available on GitHub. Feel free to take a look at it.</p>

<div class="signature">
  <img src="https://www.smashingmagazine.com/images/logo/logo--red.png" alt="Smashing Editorial">
  <span>(da, lf, ra, al, il)</span>
</div>


              </article>
            </body>
          </html>
---------------
<h1 id="#title_4" >5、文章： 为什么说Flutter让移动开发变得更好？</h1>
Aaron Oertel
[http://www.infoq.com/cn/articles/why-flutter-will-change-mobile-development-for-the-best?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/why-flutter-will-change-mobile-development-for-the-best?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/why-flutter-will-change-mobile-development-for-the-best/zh/smallimage/logo+%288%29-1532262182720.jpg"/><p>如果你是Android开发者，那么可能已经听说过Flutter。 这是一个相对较新，用来开发跨平台原生应用的框架。 这不是第一个移动领域用于跨平台开发的框架，但它正在被谷歌使用，得益于谷歌的实力，让Flutter有一定的可信度。 尽管最初持有保留意见，但我决定尝试一下 - 结果Flutter在一周内彻底改变了我对移动开发的看法。 下面是我学到的东西。</p> <i>By Aaron Oertel</i> <i> Translated by Daniel_Hu</i>
---------------
<h1 id="#title_5" >6、文章： Python自动化测试框架有哪些？</h1>
KITTY GUPTA
[http://www.infoq.com/cn/articles/python-frameworks-available-test-automation?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/python-frameworks-available-test-automation?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/python-frameworks-available-test-automation/zh/smallimage/tb-1532261192175.jpg"/><p>不同的项目需要不同的测试用例、假设和脚本，这也是为什么会在开发自己的测试框架中花费大量时间。随着技术的进步和自动化技术的出现，市面上出现了一些自动化测试框架。只需要进行一些适用性和效率参数的调整，这些自动化测试框架就能够开箱即用，大大节省了开发时间。由于这些框架被广泛使用，他们具有很好的健壮性，并且具有广泛多样的用例集和技术来轻易发现微小的缺陷。今天，我们将看一看可用的Python自动化测试框架。</p> <i>By KITTY GUPTA</i> <i> Translated by 张健欣</i>
---------------
<h1 id="#title_6" >7、视频演讲： UMStor：数字时代的分布式多协议统一存储实践</h1>
方勇
[http://www.infoq.com/cn/presentations/umstor-distributed-multi-protocol-unified-storage-practice?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/umstor-distributed-multi-protocol-unified-storage-practice?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/presentations/umstor-distributed-multi-protocol-unified-storage-practice/zh/mediumimage/fangyong270-1532434871840.jpg"/><p>在万物互联的智能时代，随着云计算日渐普及、大数据兴起以及人工智能在各个领域的不断深入和渗透，数据呈现比以往更为快速的增长，今天的我们不仅仅需要解决数据怎么“存”的问题，还要应对数据怎么“用”的烦恼。企业内部只有实现数据的有效流动，才能实现数据分析时所需数据源的多样性，依据多样的数据进行数据融合处理，才能实现数据的再造目标。

本次演讲将着重分享UMStor的设计思路和实践经验，揭露UMStor数据存储系统是如何通过技术创新，让统一存储技术在大数据环境下绽放新的魅力。</p> <i>By 方勇</i>
---------------
<h1 id="#title_7" >8、文章： 猫、量子位和远距传动：令人匪夷所思的量子计算世界（第三部分）</h1>
Holly Cummins
[http://www.infoq.com/cn/articles/quantum-computing-applications-three?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/quantum-computing-applications-three?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/quantum-computing-applications-three/zh/smallimage/quantum-computation-1531439074361-1532194946841.jpg"/><p>这是量子计算系列的第三部分，第一部分侧重介绍了量子计算，第二部分介绍了量子算法。</p> <i>By Holly Cummins</i> <i> Translated by 无明</i>
---------------
<h1 id="#title_8" >9、视频演讲： Tencent Hub技术架构与DevOps落地实践揭秘</h1>
彭磊
[http://www.infoq.com/cn/presentations/tencenthub-technical-framework-and-practice-of-devops-landing?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/tencenthub-technical-framework-and-practice-of-devops-landing?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/presentations/tencenthub-technical-framework-and-practice-of-devops-landing/zh/mediumimage/penglei270-1531487055622.jpg"/><p>TencentHub是一个集Docker镜像、二进制文件、helmcharts于一体的仓库存储服务。通过集成自研的pipeline引擎workflow，提供一站式DevOps解决方案。议题将介绍TencentHub的技术架构，探讨如何基于Kubernetes 快速实现workflow引擎的。</p> <i>By 彭磊</i>
---------------
<h1 id="#title_9" >10、微软发布Azure Service Fabric Mesh公开预览版</h1>
Steef-Jan Wiggers
[http://www.infoq.com/cn/news/2018/07/azure-service-fabric-mesh?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2018/07/azure-service-fabric-mesh?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>Service Fabric现在在云端有了一个新亲戚——Azure Service Fabric Mesh，Azure的一个完全托管服务，开发人员现在可以基于此服务部署和运行容器化应用程序。在去年五月的Build 2018大会期间首次亮相后，现在开始进行公开预览。</p> <i>By Steef-Jan Wiggers</i> <i> Translated by 无明</i>
---------------
<h1 id="#title_10" >11、文章： 关于Go语言，你可能会讨厌的五件事</h1>
Christoph Engelbert
[http://www.infoq.com/cn/articles/5-things-you-hate-about-go?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/5-things-you-hate-about-go?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/5-things-you-hate-about-go/zh/smallimage/logo-ag-1525417039268-1532263162236.jpeg"/><p>关于Go语言，你可能会讨厌的五件事。</p> <i>By Christoph Engelbert</i> <i> Translated by 无明</i>
---------------
<h1 id="#title_11" >12、为所有PHP-FPM容器构建单独的Nginx Docker镜像</h1>
Karl Hughes
[http://www.infoq.com/cn/news/2018/07/PHP-fpm-container-nginxdock?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2018/07/PHP-fpm-container-nginxdock?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>在该文中，作者介绍了自己在PHP应用中，给容器构建NGinx镜像使用的三种方法，即每个API一个Nginx镜像，所有API共用1个NGinx镜像及最终采用的方法定制解决方案。文中列出了部分配置和代码，可供读者参考。</p> <i>By Karl Hughes</i> <i> Translated by 方彦</i>
---------------
<h1 id="#title_12" >13、Kotlin生态调查结果出炉：超过6成的开发者用过Kotlin了</h1>
Pusher
[http://www.infoq.com/cn/news/2018/07/Kotlin-State-over60percent?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2018/07/Kotlin-State-over60percent?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>Kotlin从2011年低调问世，在短短几年间，如冲天火箭般流行起来。一年前，谷歌宣布将Kotlin指定为Android官方编程语言；来自Stack Overflow的一项问卷调查显示，超过10万名受调者表示Kotlin是他们的第二大编程语言。英国软件公司Pusher对此感到非常好奇，究竟Kotlin有什么特别的地方，让开发者如此着迷。于是，Pusher公司发起了一项针对Kotlin生态系统的问卷调查，从2018年1月份至3月份，为期三个月，受调者达到2744名。以下是这份问卷调查的结果及其简要分析。</p> <i>By Pusher</i> <i> Translated by 无明</i>
---------------
<h1 id="#title_13" >14、BCCon：看当今互联网企业区块链idea的可行性</h1>
周菊
[http://www.infoq.com/cn/news/2018/07/bccon-idea-2018?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2018/07/bccon-idea-2018?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>目前对区块链前景的争议，集中于其落地方向和价值的不明朗。迷雾之中，众说纷纭，有言论称“区块链不ICO不挣钱”，也有人试图找到币圈以外区块链技术在现实场景中的真正价值。这里给大家提供一些值得关注的内容。</p> <i>By 周菊</i>
---------------