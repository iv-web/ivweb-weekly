## 文章索引
1、 <a href="#1hexchat-2140-发布开源-irc-客户端" >Hexchat 2.14.0 发布，开源 IRC 客户端</a><br/>
2、 <a href="#2文章-uber的app是如何实现其商业需求的" >文章： Uber的App是如何实现其商业需求的？</a><br/>
3、 <a href="#3openpgpjs-30-发布开源-openpgp-库" >OpenPGP.js 3.0 发布，开源 OpenPGP 库</a><br/>
4、 <a href="#4openkit-1111java-第三方-api-整合" >OpenKit 1.1.11，Java 第三方 API 整合</a><br/>
5、 <a href="#5facebook产品经理的三年叙事与协作思考" >Facebook产品经理的三年叙事与协作思考</a><br/>
6、 <a href="#6coffeescript-223-发布编译成-js-的小巧语言" >CoffeeScript 2.2.3 发布，编译成 JS 的小巧语言</a><br/>
7、 <a href="#7netrunner-1803-发布基于-ubuntu-的发行" >Netrunner 18.03 发布，基于 Ubuntu 的发行</a><br/>
8、 <a href="#8mybatis-346-发布java-数据持久层框架" >MyBatis 3.4.6 发布，Java 数据持久层框架</a><br/>
9、 <a href="#9linux-kernel-441214987414264159-等发布" >Linux Kernel 4.4.121，4.9.87，4.14.26，4.15.9 等发布</a><br/>
10、 <a href="#10文章-在kotlin中使用gradle构建缓存" >文章： 在Kotlin中使用Gradle构建缓存</a><br/>
11、 <a href="#11快嘉框架-v16-更新发布j2ee-开发框架实例" >快嘉框架 v1.6 更新发布，J2EE 开发框架实例</a><br/>
12、 <a href="#12若依管理系统-105-发布新增菜单管理" >若依管理系统 1.0.5 发布，新增菜单管理</a><br/>
13、 <a href="#13jetty-949v20180311-发布bug-fix-版本" >Jetty 9.4.9.v20180311 发布，bug fix 版本</a><br/>
14、 <a href="#14javascript-仍然位居榜首typescript-也不甘落后" >JavaScript 仍然位居榜首，TypeScript 也不甘落后</a><br/>
15、 <a href="#15vue-2515-发布大量-bug-修复和重构" >Vue 2.5.15 发布，大量 Bug 修复和重构</a><br/>
16、 <a href="#16协作翻译-|-二月份十大新开发工具" >协作翻译 | 二月份十大新开发工具</a><br/>
17、 <a href="#17arxiv-中最受欢迎的开源框架tensorflow-排名第一" >ArXiv 中最受欢迎的开源框架，TensorFlow 排名第一</a><br/>
18、 <a href="#18car-eye-device-多路行车记录仪功能模块的解决方案" >Car-eye-device — 多路行车记录仪功能模块的解决方案</a><br/>
19、 <a href="#19码云推荐-|-基于-swoole-的内网穿透支持本地微信开发" >码云推荐 | 基于 Swoole 的内网穿透，支持本地微信开发</a><br/>
20、 <a href="#206-个新奇的编程方式改变你对编码的认知" >6 个新奇的编程方式，改变你对编码的认知</a><br/>
21、 <a href="#21每日一博-|-从零开始写简易读写分离并不复杂" >每日一博 | 从零开始写简易读写分离并不复杂</a><br/>
22、 <a href="#22五大-java-web-框架的优缺点对比spring-mvc-领先" >五大 JAVA Web 框架的优缺点对比，Spring MVC 领先</a><br/>
23、 <a href="#23文章-敏捷规划时间表" >文章： 敏捷规划时间表</a><br/>
24、 <a href="#24oschina-周日乱弹-爱丽丝爱吃京酱肉丝" >OSChina 周日乱弹 —— 爱丽丝爱吃京酱肉丝</a><br/>
25、 <a href="#25google-意图让-amp-网页快速载入技术成为标准" >Google 意图让 AMP 网页快速载入技术成为标准</a><br/>
26、 <a href="#26视频演讲-uc浏览器容器化架构演进之路" >视频演讲： UC浏览器容器化架构演进之路</a><br/>
27、 <a href="#277-zip-1803-beta-发布数据压缩程序" >7-Zip 18.03 beta 发布，数据压缩程序</a><br/><h1 id="#title_0" >1、Hexchat 2.14.0 发布，开源 IRC 客户端</h1>

[https://www.oschina.net/news/94097/hexchat-2-14-0](https://www.oschina.net/news/94097/hexchat-2-14-0)
<p>Hexchat 2.14.0 发布了。Hexchat 是一种可以运行在 Windows、Linux 和 Unix 上的开源 GTK + IRC 客户端。HexChat 基于 XChat 开发，但 Hexchat 在任何平台上都是完全免费的。</p><p>主要更新内容：</p><ul class="simple list-paddingleft-2"><li><p>rewrite build system in&nbsp;</p></li></ul>
---------------
<h1 id="#title_1" >2、文章： Uber的App是如何实现其商业需求的？</h1>
Dmytro Brovkin
[http://www.infoq.com/cn/articles/how-uber-was-made?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/how-uber-was-made?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/how-uber-was-made/zh/smallimage/logo1-1520706607664.jpg"/><p>Uber通过创新的产品设计解决了打车的问题，它的成功源于多方面的因素，包括清晰的商业模式和基于交互的产品设计。但是当我们也想构建一个像Uber这样的app来为自己的商业需求服务时，又该如何做呢？</p> <i>By Dmytro Brovkin</i> <i> Translated by 孙浩</i>
---------------
<h1 id="#title_2" >3、OpenPGP.js 3.0 发布，开源 OpenPGP 库</h1>

[https://www.oschina.net/news/94077/openpgpjs-3-0](https://www.oschina.net/news/94077/openpgpjs-3-0)
<p>安全电子邮件服务商 ProtonMail 刚刚宣布了 OpenPGPjs 的 3.0 版本。作为一款开源 OpenPGP 库，本次更新为数以百万计依赖于 OpenPGPjs 的用户带来了大量的增强。同时，新版也为 ProtonMail 和 PGP 完全互通的操作铺平了道路。ProtonMail 在博客文章中表示：“openPGPjs 项目的目标，不仅仅是为用户、也为全球开发者社区带来公钥加密”。<br/></p><p><img src="https://static.cnbetacdn.com/article/2018/0310/fc7ea862ba373f9.jpg" alt="1520612171_protonmail-openpgpjs-v3-release-open-source-library-im_story.jpg"/></p><p>“简而言之，隐私革命的前提，就是开放源码和安全加密库的广泛可用性。作为 OpenPGPjs 项目的维护者，这是我们的首要任务”。</p><p>3.0 版本还带来了许多增强，使得 ProtonMail 与 PGP 的完全互操作成为了可能，这项新特性将于今年春季到来。</p><p>详细的更新内容，请参阅</p>
---------------
<h1 id="#title_3" >4、OpenKit 1.1.11，Java 第三方 API 整合</h1>

[https://www.oschina.net/news/94089/openkit-1-1-11](https://www.oschina.net/news/94089/openkit-1-1-11)
<p>Java 开发中 SSM（SpringMVC+Spring+MyBatis）组合框架，在开发的过程中，很多时候我们需要反复，频繁的验证我们对象中的字段，这造成了我们很多的冗余代码，为了优雅的验证字段，OpenKit 昨晚升级发布 1.1.11，竟然偷偷加了一个字段验证的功能。</p><p>更新内容：</p><p>添加了利用注解的方式对对象进行验证的方法</p><p><img src="https://static.oschina.net/uploads/space/2018/0311/131047_qOfB_3121392.png" alt=""/></p><p>openkit标志</p><p>其中OpenKit给我们提供了几个简单的验证</p><p><img src="http://p3.pstatp.com/large/6ed200032ee314646cc8" alt="java的SSM框架，配合OpenKit1.1.11，验证字段变得如此简单"/></p><p>常规注解</p><p>除了上面的，还有一个对条件验证的注解：@KitIsPlus</p><p>代码案例：</p><p><img src="http://p3.pstatp.com/large/6c3f000462837f1014ee" alt="java的SSM框架，配合OpenKit1.1.11，验证字段变得如此简单"/></p><p>这里给我们提供了常规的几种验证，自己可以独立组合</p><p><img src="http://p1.pstatp.com/large/6ed200032fe8f9b6442f" alt="java的SSM框架，配合OpenKit1.1.11，验证字段变得如此简单"/></p><p>KitIsPlus给我们提供的基本验证参数</p><p>嵌套属性注意事项</p><p>为了方便大家的使用，OpenKit给大家提供了两个嵌套属性min，max，先来个Demo吧</p><p><img src="http://p3.pstatp.com/large/6c3d0005bb9f2c50b763" alt="java的SSM框架，配合OpenKit1.1.11，验证字段变得如此简单"/></p><p>demo</p><p>可以看出，嵌套属性我们可以在前面写上属性名，英文:[color=rgba(0, 0, 0, 0.87)]后面加上属性值，一样的我们会从前往后依次验证</p><p><img src="http://p3.pstatp.com/large/6ed20003303a6d09f5ea" alt="java的SSM框架，配合OpenKit1.1.11，验证字段变得如此简单"/></p><p>嵌套验证参数</p><p>自定义验证</p><p>很多看官看到这里可能会发现我们有一个参数一直没有使用，那就是rule[color=rgba(0, 0, 0, 0.87)]。在我们的1.1.9版本中给大家使用了@KitIsOther[color=rgba(0, 0, 0, 0.87)]验证我们可以自定义一个正则进行验证，那么在我们这个PLUS级别的验证方法，我们当然也不能少了这个，所以如果我们提供的验证方式还是不能满足你的验证方法，比如，你想验证非空，还要验证长度是2-15位，同时还得是正整数，那么你可以这样写</p><p><img src="http://p3.pstatp.com/large/6c3d0005bbe5c4250210" alt="java的SSM框架，配合OpenKit1.1.11，验证字段变得如此简单"/></p><p>demo</p><p>看了上面的这些是不是发现，Plus没有让你们失望呢？</p><blockquote>注意：如果多个参数，前面有3个参数，提示语，必须写三个，如果带有rule，那么提示语的个数必须rule对应的提示语必须放在最后一个</blockquote>
---------------
<h1 id="#title_4" >5、Facebook产品经理的三年叙事与协作思考</h1>
David
[http://www.infoq.com/cn/news/2018/03/facebook-pm-experience?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2018/03/facebook-pm-experience?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>产品经理和研发工程师的关系经常被大家调侃，可偏偏就有同时受到研发和设计都喜欢的“别人家的产品经理”，沟通协调、对接需求、项目把控面面俱到还有好人缘。有没有人天生就是产品经理？产品经理的工作就是写需求写需求和写需求么？顶级公司的产品经理都是如何锻炼技能，提升思考能力的？</p> <i>By David</i>
---------------
<h1 id="#title_5" >6、CoffeeScript 2.2.3 发布，编译成 JS 的小巧语言</h1>

[https://www.oschina.net/news/94093/coffeescript-2-2-3-released](https://www.oschina.net/news/94093/coffeescript-2-2-3-released)
<p>CoffeeScript 2.2.3 已发布，CoffeeScript 2 最大的变化是，CoffeeScript 编译器会生成现代 JavaScript 语法（ ES6 或 ES2015 及以上版本）。一个 CoffeeScript =&gt;会变成一个 JS =&gt; ，一个 CoffeeScript 类会变成一个 JS 类，等等。此外， CoffeeScript 2 中的新特性还包括异步功能和 JSX 。</p><p>更新内容：</p><p></p><ul class=" list-paddingleft-2"><li><p>Bump version to 2.2.3; update packages</p></li><li><p>Update output</p></li><li><p>Update changelog</p></li></ul><p>下载地址：<br/></p><ul class="mt-2 list-paddingleft-2"><li><p></p></li></ul>
---------------
<h1 id="#title_6" >7、Netrunner 18.03 发布，基于 Ubuntu 的发行</h1>

[https://www.oschina.net/news/94096/netrunner-18-03](https://www.oschina.net/news/94096/netrunner-18-03)
<p>Netrunner 18.03 发布了，Netrunner 是基于 Ubuntu 的发行，它着眼于桌面计算。该发行引以为豪的是一份精心修改的 KDE &nbsp;4桌面，它带有很多集成进来的 GNOME 应用程序，从而以混合的形式向用户提供流行的和强大的应用软件。</p><p>该版本建立在 Debian&#39;s Testing 分支之上，包括 Plasma 内核 5.12 LTS，Linux 内核版本 4.14，LibreOffice 6 和 Firefox 58。</p><p>主要更新内容：<br/></p><ul class=" list-paddingleft-2"><li><p>KDE Plasma 5.12.2</p></li><li><p>KDE Frameworks 5.42</p></li><li><p>KDE Applications 17.08.3</p></li><li><p>Qt 5.9.2</p></li><li><p>Linux Kernel 4.14</p></li><li><p>Firefox Quantum 58.0.1</p></li><li><p>Thunderbird 52.6.0</p></li><li><p>LibreOffice 6.0.2</p></li></ul><p>)<br/></p></li></ul>
---------------
<h1 id="#title_7" >8、MyBatis 3.4.6 发布，Java 数据持久层框架</h1>

[https://www.oschina.net/news/94095/mybatis-3-4-6-released](https://www.oschina.net/news/94095/mybatis-3-4-6-released)
<p>MyBatis 3.4.6 发布了。主要更新内容如下：</p><p>提升</p><ul class=" list-paddingleft-2"><li><p>将自定义ResultHandler应用于CURSOR类型OUT参数。&nbsp;</p></li></ul>
---------------
<h1 id="#title_8" >9、Linux Kernel 4.4.121，4.9.87，4.14.26，4.15.9 等发布</h1>

[https://www.oschina.net/news/94094/linux-kernel-4-4-121](https://www.oschina.net/news/94094/linux-kernel-4-4-121)
<p>Linux Kernel 4.4.121，4.9.87，4.14.26，4.15.9，3.18.99 发布了。</p><table><tbody><tr class="firstRow"><th align="right">Version:</th><td><strong>4.4.121</strong>&nbsp;(longterm)</td></tr><tr><th align="right">Released:</th><td>2018-03-11</td></tr><tr><th align="right">Source:</th><td></td></tr></tbody></table>
---------------
<h1 id="#title_9" >10、文章： 在Kotlin中使用Gradle构建缓存</h1>
Eric Wendelin
[http://www.infoq.com/cn/articles/using-gradle-build-cache-with-kotlin?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/using-gradle-build-cache-with-kotlin?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/using-gradle-build-cache-with-kotlin/zh/smallimage/kafak-1520707613842.jpg"/><p>Kotlin 1.2.21允许Kotlin项目使用构建缓存。通过Gradle的构建缓存功能，可以提升Kotlin代码的编译速度，加快开发周期。本文将结合实际例子，介绍利用Gradle加速Kotlin代码编译的原理、配置示例以及在IDE中的使用方法。</p> <i>By Eric Wendelin</i> <i> Translated by 张健欣</i>
---------------
<h1 id="#title_10" >11、快嘉框架 v1.6 更新发布，J2EE 开发框架实例</h1>

[https://www.oschina.net/news/94092/kuaijia-1-6](https://www.oschina.net/news/94092/kuaijia-1-6)
<p>快嘉开发框架将一个标准的J2EE项目拆分为基础组件(Base)、持久层组件(Persistence-Impl)、接口和报文定义组件(Bundle)、接口模拟实现组件(BundleMock)、业务实现组件(Service-Impl)、批处理系统（Batch）、接口系统(Api)和接口测试组件(SDK)8个部分并行开发建设，其中基础组件(Base)、接口和报文定义组件(Bundle)、接口模拟实现组件(BundleMock)和接口测试组件(SDK)都可以由快嘉网平台提供的代码生成服务生成。该框架基于spring4+mybatis3.3.0搭建，持久层为mysql。</p><p>v1.6更新如下</p><ul class=" list-paddingleft-2"><li><p>调整私服地址，同时支持nexus2和nexus3</p></li><li><p>升级相关jar</p></li><li><p>升级相关maven为最新版本</p></li><li><p>BaseDao模块新增批量插入数据方法、新增以多列为联合主键查询、修改和删除方法</p></li><li><p>整体去掉Mbg依赖，新增Persistence-Impl-Mbg模块演示Mbg玩法</p></li></ul><p>具体使用说明参见</p>
---------------
<h1 id="#title_11" >12、若依管理系统 1.0.5 发布，新增菜单管理</h1>

[https://www.oschina.net/news/94091/ruoyi-1-0-5](https://www.oschina.net/news/94091/ruoyi-1-0-5)
<h3><strong>v1.0.5 更新日志</strong></h3><p>1、新增菜单管理操作（增、删、改、查、树）<br/>2、部门管理新增责任人、手机、邮箱</p><h3><strong>平台简介</strong></h3><p>一直想做一款后台管理系统，看了很多优秀的开源项目但是发现没有合适自己的。于是利用空闲休息时间开始自己写一套后台系统。如此有了若依管理系统。她可以用于所有的Web应用程序，如网站管理后台，网站会员中心，CMS，CRM，OA。所有前端后台代码封装过后十分精简易上手，出错效率低。同时支持移动客户端访问。系统会陆续更新一些实用功能。</p><p>若依是给刚出生的女儿取的名字 寓意：你若不离不弃，我必生死相依</p><h3>部分功能演示<br/></h3><p><img src="https://static.oschina.net/uploads/space/2018/0301/160757_fnZP_1438828.png"/></p><p><img src="https://static.oschina.net/uploads/space/2018/0303/011028_xWoa_1438828.png"/></p><p></h2>
---------------
<h1 id="#title_12" >13、Jetty 9.4.9.v20180311 发布，bug fix 版本</h1>

[https://www.oschina.net/news/94090/jetty-9-4-9-20180311](https://www.oschina.net/news/94090/jetty-9-4-9-20180311)
<p>Jetty 9.4.9.v20180311 发布了，Jetty 是一个开源的 servlet 容器，它为基于 Java 的 web 内容，例如 JSP 和 servlet 提供运行环境。Jetty 是使用 Java 语言编写的，它的 API 以一组 JAR 包的形式发布。开发人员可以将 Jetty 容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的 Java 应用提供网络和 web 连接。</p><p>修复了很多很多的问题, 是9.4.x分支的稳定版本</p><p>英文原话是:</p><blockquote><p>Many many fixes, see above link for list.</p><p>This is a restage of a potential release of the Jetty 9.4.x branch, and exists on a&nbsp;</p></li></ul>
---------------
<h1 id="#title_13" >14、JavaScript 仍然位居榜首，TypeScript 也不甘落后</h1>

[https://www.oschina.net/news/94080/javascript-rules-but-microsoft-programming-on-the-rise](https://www.oschina.net/news/94080/javascript-rules-but-microsoft-programming-on-the-rise)
<p>根据以开发人员为中心的分析公司RedMonk的2018年第一季度排名，JavaScript仍然是最受欢迎的编程语言，但微软提供的两款产品正在稳步增长。</p><p>RedMonk的排名是基于GitHub中的pull请求和在开发人员知识共享站点Stack Overflow上标记语言的次数决定的。根据这些数据，RedMonk分析师Stephen O&#39;Grady&nbsp;认为，&nbsp;与去年一样JavaScript是当今最流行的语言。</p><p>实际上，RedMonk的前10名中没有任何变化，除了苹果的Swift上升和Objective-C并列，排在第 10 位。</p><p><img alt="" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0311/071312_2rE7_3703517.png" src="https://static.oschina.net/uploads/space/2018/0311/071312_2rE7_3703517.png"/></p><p>而前10种编程语言分别是 JavaScript，Java，PHP，Python，C＃，C ++，CSS，Ruby 和 C，其中第十个是Swift 和 Objective-C。</p><p>TIOBE&nbsp;</p>
---------------
<h1 id="#title_14" >15、Vue 2.5.15 发布，大量 Bug 修复和重构</h1>

[https://www.oschina.net/news/94088/vue-2-5-15](https://www.oschina.net/news/94088/vue-2-5-15)
<p>Vue 在 2.5.14 做了许多重构和Bug修复，在发布一天后又发布了&nbsp;2.5.15 修复被发现的严重 Bug。</p><h3>2.5.15 Bug Fixes</h3><ul class=" list-paddingleft-2"><li><p>do not traverse VNodes when regsitering dependencies&nbsp;</p></li><li><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
					fix ssr env detection in weex (</p></li></ul>
---------------
<h1 id="#title_15" >16、协作翻译 | 二月份十大新开发工具</h1>

[https://www.oschina.net/translate/dev-tools-roundup-3](https://www.oschina.net/translate/dev-tools-roundup-3)
<p>然而，在月尾，让我们花一点时间赞美总结一下二月份的十大新开发工具吧。</p>
---------------
<h1 id="#title_16" >17、ArXiv 中最受欢迎的开源框架，TensorFlow 排名第一</h1>

[https://www.oschina.net/news/94086/tensorflow-at-the-frist](https://www.oschina.net/news/94086/tensorflow-at-the-frist)
<p>近日 Keras 作者 François Chollet 近日在 Twitter 上公布了一项他所做的调查，统计了在过去三个月中 ArXiv 上（截至 3 月 7 日）被提及（mention）最多的几大开源框架。结果显示，谷歌开源的 TensorFlow 以超过 800 的「存在感」毫无争议得获得了第一名。</p><p>第二至第四名分别是基于 Python 的深度学习库 Keras、同属 facebook 的 Caffe 和 PyTorch；去年已宣布停止更新的 Theano、亚马逊官方开源平台 MxNet、英特尔的 Chainer 及微软&nbsp;CNTK 则分列其后。</p><p><img alt="" height="487" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0311/003302_thnq_3703517.jpg" src="https://static.oschina.net/uploads/space/2018/0311/003302_thnq_3703517.jpg" width="700"/></p><p>据 François Chollet 在 Twitter 上回复 @Jack Clack 所言，这一统计数据仅仅是通过谷歌搜索指数来筛选的，也没有对论文的详细文本进行细致分析，但他认为这样的统计方式会更加准确。</p><p>此外他也在后续的 Twitter 上提及，统计数据表明，相对于学术研究领域，Keras 更受工业界的欢迎，而且大公司和创业公司都「通吃」；另外在数据科学社群，Keras 也有着颇高的人气。</p><p><img alt="" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0311/003334_ExPS_3703517.jpg" src="https://static.oschina.net/uploads/space/2018/0311/003334_ExPS_3703517.jpg"/></p><p>Keras 于 2015 年正式发布，在 2017 年 3 月更新了 Keras 2，并于 8 月进一步更新功能。目前 Keras 在 GitHub 上拥有 star 数 26393 个，fork 数 9625 个，有 635 位开发者为它的发展做出贡献。Keras 是一个用 Python 编写的高级神经网络 API，它能够以 TensorFlow, CNTK, 或者 Theano 作为后端运行。Keras 的开发重点是支持快速的实验。能够以最小的时延把你的想法转换为实验结果，是做好研究的关键。</p><p>此外，François Chollet 还统计了开源框架们的「综合人气指数」，这回排名则有所变化，第一名仍然是 TensorFlow。值得一提的是，百度的 PaddlePaddle 也入选了这一榜单，还有一个新面孔是包括深度学习框架 deeplearning4j。</p><p><img alt="" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0311/003431_TTxe_3703517.jpg" src="https://static.oschina.net/uploads/space/2018/0311/003431_TTxe_3703517.jpg"/></p><p>而在过去一个月内（2018 年 2 月 10 日至 2018 年 3 月 8 日），在 GitHub 上的新 Fork 数则由 TensorFlow 包揽大局，凭借 10836 的新 Fork 数承包了该榜单冠军；比后续 10 个开源框架的总和加起来还多得多（第二名的 Keras 有 439 个）。</p><p><img alt="" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0311/003455_yQVt_3703517.jpg" src="https://static.oschina.net/uploads/space/2018/0311/003455_yQVt_3703517.jpg"/></p><p>来自：</p>
---------------
<h1 id="#title_17" >18、Car-eye-device — 多路行车记录仪功能模块的解决方案</h1>

[https://www.oschina.net/p/car-eye-device](https://www.oschina.net/p/car-eye-device)
<p>car-eye 设备子系统提供了一整套硬件设计、固件程序、系统软件、行车记录仪等功能模块的解决方案。</p>
---------------
<h1 id="#title_18" >19、码云推荐 | 基于 Swoole 的内网穿透，支持本地微信开发</h1>

[https://gitee.com/yurunsoft/YurunProxy](https://gitee.com/yurunsoft/YurunProxy)
<p>基于 Swoole 的内网穿透，支持本地微信开发、Web开发，让外网能够访问到！山寨简易版 Ngrok！</p>
---------------
<h1 id="#title_19" >20、6 个新奇的编程方式，改变你对编码的认知</h1>

[https://www.oschina.net/news/94083/six-programming-paradigms-that-will-change-how](https://www.oschina.net/news/94083/six-programming-paradigms-that-will-change-how)
<p>我时不时会发现一种编程语言的不同用法它有时候会改变我对编程的看法啊。这篇文章中，我想分享一下让我惊讶的发现。这不是类似于高呼“函数式编程会改变世界！”博客文章。我敢打赌，大多数读者都没有听说过下面的大多数语言和范例，所以你应该也会被这些新概念吸引。</p><p>注意：我对以下大多数语言的使用经验都很少，但是我发现他们背后的想法非常吸引人，但对其没有专业知识，所以有任何错误请指出并指导更正。如果您也有新的范例和想法，欢迎分享。</p><h3>默认并发</h3><p><img alt="" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0309/170904_Ywda_3703517.jpg" src="https://static.oschina.net/uploads/space/2018/0309/170904_Ywda_3703517.jpg"/></p><p>示例语言：</p><p>让我们用一个哲学家的思想来解决问题吧：有些编程语言是默认情况下并发的，也就是说，每行代码都是并行执行的。</p><p>例如，假设你写了三行代码，A，B和C：</p><pre data-cke-widget-data="%7B%22code%22%3A%22A%3B%5CnB%3B%5CnC%3B%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">A;
B;
C;</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>在大多数编程语言中，A先执行，然后执行B，最后执行C。在像中代码行之间的控制流或排序，仅仅是代码行之间显式依赖关系的副作用。例如，如果B引用了A中定义的变量，则A和C将同时执行，而B只会在A完成后执行。</p><p>以下是ANI中的“Hello World”示例：</p><pre data-cke-widget-data="%7B%22code%22%3A%22%5C%22Hello%2C%20World!%5C%22%20-%3Estd.out%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">&quot;Hello,&nbsp;World!&quot;&nbsp;-&gt;std.out</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>在ANI术语中，我们将<code>&quot;Hello, World!&quot;</code>对象（字符串）发送到<code>std.out</code>流。如果我们发送另一个字符串，会发生&nbsp;<code>std.out</code>什么</p><pre data-cke-widget-data="%7B%22code%22%3A%22%5C%22Hello%2C%20World!%5C%22%20-%3Estd.out%5Cn%5C%22Goodbye%2C%20World!%5C%22%20-%3Estd.out%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">&quot;Hello,&nbsp;World!&quot;&nbsp;-&gt;std.out
&quot;Goodbye,&nbsp;World!&quot;&nbsp;-&gt;std.out</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>这两行代码并行执行，因此它们可以在控制台中以任何顺序结束。现在，看看当我们在一行上引入一个变量并参考它会发生什么：</p><pre data-cke-widget-data="%7B%22code%22%3A%22s%20%3D%20%5Bstring%5C%5C%5D%3B%5Cn%5C%22Hello%2C%20World!%5C%22%20-%3Es%3B%5Cn%5C%5Cs%20-%3Estd.out%3B%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">s&nbsp;=&nbsp;[string\];
&quot;Hello,&nbsp;World!&quot;&nbsp;-&gt;s;
\s&nbsp;-&gt;std.out;</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>第一行声明一个“锁存（latch）”（锁存器有点像变量），调用&nbsp;<code>s</code>它包含一个字符串;&nbsp;第二行将文本赋值&nbsp;<code>&quot;Hello, World!&quot;</code>给<code>s</code>;&nbsp;第三行“解锁”&nbsp;<code>s</code>并将内容发送给<code>std.out</code>。在这里，您可以看到ANI的隐式程序排序：由于每行都依赖于前一行，因此此代码将按写入的顺序执行。</p><p>Plaid 语言还声称通过默认支持并发性，但使用权限模型，如在本文中，设置控制流程。多核技术正在兴起，并发性仍然是大多数语言中难点。ANI 和 Plaid 提供了一个新的解决方案，可以带来惊人的性能提升;，问题在于“默认并行”是否会改变开发的状态。有关更多信息，请参阅</p><p>你可能习惯使用C和Java等语言来键入系统，编译器可以检查变量是整数，列表还是字符串。但是如果你的编译器能检查一个变量是“一个正整数”，“一个长度为2的列表”还是“一个回文字符串”呢？</p><p>下面是如何声明一个<code>Vector</code>包含无形库1,2,3的值：</p><pre data-cke-widget-data="%7B%22code%22%3A%22val%20l1%20%3D%201%20%3A%23%3A%202%20%3A%23%3A%203%20%3A%23%3A%20VNil%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">val&nbsp;l1&nbsp;=&nbsp;1&nbsp;:#:&nbsp;2&nbsp;:#:&nbsp;3&nbsp;:#:&nbsp;VNil</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>这将创建一个变量<code>l1</code>，它的类型签名不仅指定它<code>Vector</code>是包含的<code>Ints</code>，而且指定它的<code>Vector</code>长度为3.编译器可以使用此信息来捕获错误。让我们使用该<code>vAdd</code>方法在<code>Vector</code>两个之间执行成对加法<code>Vectors</code>：</p><pre data-cke-widget-data="%7B%22code%22%3A%22val%20l1%20%3D%201%20%3A%23%3A%202%20%3A%23%3A%203%20%3A%23%3A%20VNil%5Cnval%20l2%20%3D%201%20%3A%23%3A%202%20%3A%23%3A%203%20%3A%23%3A%20VNil%5Cn%20%5Cnval%20l3%20%3D%20l1%20vAdd%20l2%5Cn%20%5Cn%2F%2F%20Result%3A%20l3%20%3D%202%20%3A%23%3A%204%20%3A%23%3A%206%20%3A%23%3A%20VNil%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">val&nbsp;l1&nbsp;=&nbsp;1&nbsp;:#:&nbsp;2&nbsp;:#:&nbsp;3&nbsp;:#:&nbsp;VNil
val&nbsp;l2&nbsp;=&nbsp;1&nbsp;:#:&nbsp;2&nbsp;:#:&nbsp;3&nbsp;:#:&nbsp;VNil
&nbsp;
val&nbsp;l3&nbsp;=&nbsp;l1&nbsp;vAdd&nbsp;l2
&nbsp;
//&nbsp;Result:&nbsp;l3&nbsp;=&nbsp;2&nbsp;:#:&nbsp;4&nbsp;:#:&nbsp;6&nbsp;:#:&nbsp;VNil</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>上面的例子工作正常，因为类型系统知道两者&nbsp;<code>Vectors</code>都有长度3.但是，如果我们尝试了<code>vAdd</code>&nbsp;两种<code>Vectors</code>不同的长度，我们没等到运行时就会在编译时得到一个错误。</p><pre data-cke-widget-data="%7B%22code%22%3A%22val%20l1%20%3D%201%20%3A%23%3A%202%20%3A%23%3A%203%20%3A%23%3A%20VNil%5Cnval%20l2%20%3D%201%20%3A%23%3A%202%20%3A%23%3A%20VNil%5Cn%20%5Cnval%20l3%20%3D%20l1%20vAdd%20l2%5Cn%20%5Cn%2F%2F%20Result%3A%20a%20*compile*%20error%20because%20you%20can&#39;t%20pairwise%20add%20vectors%20%5Cn%2F%2F%20of%20different%20lengths!%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">val&nbsp;l1&nbsp;=&nbsp;1&nbsp;:#:&nbsp;2&nbsp;:#:&nbsp;3&nbsp;:#:&nbsp;VNil
val&nbsp;l2&nbsp;=&nbsp;1&nbsp;:#:&nbsp;2&nbsp;:#:&nbsp;VNil
&nbsp;
val&nbsp;l3&nbsp;=&nbsp;l1&nbsp;vAdd&nbsp;l2
&nbsp;
//&nbsp;Result:&nbsp;a&nbsp;*compile*&nbsp;error&nbsp;because&nbsp;you&nbsp;can&#39;t&nbsp;pairwise&nbsp;add&nbsp;vectors&nbsp;
//&nbsp;of&nbsp;different&nbsp;lengths!</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>Shapeless 是一个仍然有点粗糙的库，只支持依赖类型的一个子集，并有相当冗长的代码和类型签名。相反，中的一个简单例子&nbsp;：</p><pre data-cke-widget-data="%7B%22code%22%3A%222%203%20%2B%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">2&nbsp;3&nbsp;+</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>在这里，我们将两个数字推入堆栈，然后调用该<code>+</code>函数，将两个数字从堆栈中弹出，并将其添加到堆栈中的结果：代码的输出为5。下面是一个稍微有趣的示例：</p><pre data-cke-widget-data="%7B%22code%22%3A%22def%20foo%20%7B%5Cn%20%2010%20%3C%5Cn%20%20%5B%200%20%5D%5Cn%20%20%5B%2042%20%5D%5Cn%20%20if%5Cn%7D%5Cn%20%5Cn20%5Cnfoo%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">def&nbsp;foo&nbsp;{
&nbsp;&nbsp;10&nbsp;&lt;
&nbsp;&nbsp;[&nbsp;0&nbsp;]
&nbsp;&nbsp;[&nbsp;42&nbsp;]
&nbsp;&nbsp;if
}
&nbsp;
20
foo</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>让我们一行一行地浏览一下：</p><ol class=" list-paddingleft-2"><li><p>首先，我们声明一个函数<code>foo</code>。请注意，cat中的函数没有指定输入参数：所有参数都从堆栈中隐式读取。</p></li><li><p><code>foo</code>调用<code>&lt;</code>函数，该函数弹出的第一项在堆栈中，将它与10，并且推动任一<code>True</code>或&nbsp;<code>False</code>背面压入堆栈。</p></li><li><p>接下来，我们将值0和42输入堆栈：我们将它们包括在括号中以确保它们未被执行就推入堆栈。这是因为它们将分别用于调用<code>if</code>下一行函数的“then”和“else”分支。</p></li><li><p>该<code>if</code>函数从堆栈中弹出3个项目：布尔条件，“then”分支和“else”分支。根据布尔条件的值，它会将“then”或“else”分支的结果输回堆栈。</p></li><li><p>最后，我们将20输入堆栈并调用<code>foo</code>函数。</p></li><li><p>当所有的事情都做完后，会得到一个42的结果</p></li></ol><p>这种编程风格颇有趣味：程序可以以无数种方式拆分和连接以创建新程序;&nbsp;非常简单的语法（甚至比LISP更简单），导致非常简洁的程序; 也具有强大的元编程支持。看起来你必须记住或想象堆栈的当前状态，而不是能够从代码中的变量名称中读取它，这可能使得很难推断代码。</p><h3>声明式编程</h3><p><img alt="" height="400" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0309/181057_jyQu_3703517.png" src="https://static.oschina.net/uploads/space/2018/0309/181057_jyQu_3703517.png" width="400"/></p><p>示例语言：这样的声明性语言对数字进行排序&nbsp;，则应该描述所需的输出：“我需要相同的值列表，但索引中的每个项目&nbsp;<code>i</code>应小于或等于索引处的项目<code>i + 1</code>”。将以前的C解决方案与此Prolog代码进行比较：</p><pre data-cke-widget-data="%7B%22code%22%3A%22sort_list(Input%2C%20Output)%20%3A-%5Cn%20%20permutation(Input%2C%20Output)%2C%5Cn%20%20check_order(Output).%5Cn%20%20%5Cncheck_order(%5B%5D).%5Cncheck_order(%5BHead%5D).%5Cncheck_order(%5BFirst%2C%20Second%20%7C%20Tail%5D)%20%3A-%5Cn%20%20First%20%3D%3C%20Second%2C%5Cn%20%20check_order(%5BSecond%20%7C%20Tail%5D).%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">sort_list(Input,&nbsp;Output)&nbsp;:-
&nbsp;&nbsp;permutation(Input,&nbsp;Output),
&nbsp;&nbsp;check_order(Output).
&nbsp;&nbsp;
check_order([]).
check_order([Head]).
check_order([First,&nbsp;Second&nbsp;|&nbsp;Tail])&nbsp;:-
&nbsp;&nbsp;First&nbsp;=&lt;&nbsp;Second,
&nbsp;&nbsp;check_order([Second&nbsp;|&nbsp;Tail]).</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>如果你使用过SQL，那么你已经完成了一种声明式编程，你可能没有意识到这一点：当你发出查询时<code>select X from Y where Z</code>，你正在描述你想要返回的数据集；它是真正计算出如何执行查询的数据库引擎。</p><p>声明性语言的美妙之处在于它允许你在更高层次的抽象中工作：你只需要描述所需输出的规范。例如，的代码，只是列出了解决的数独谜题的每行，每列和对角线应该是什么样的：</p><pre data-cke-widget-data="%7B%22code%22%3A%22sudoku(Puzzle%2C%20Solution)%20%3A-%5Cn%20%20Solution%20%3D%20Puzzle%2C%5Cn%20%20%5Cn%20%20Puzzle%20%3D%20%5BS11%2C%20S12%2C%20S13%2C%20S14%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20S21%2C%20S22%2C%20S23%2C%20S24%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20S31%2C%20S32%2C%20S33%2C%20S34%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20S41%2C%20S42%2C%20S43%2C%20S44%5D%2C%5Cn%20%20%5Cn%20%20fd_domain(Solution%2C%201%2C%204)%2C%5Cn%20%20%5Cn%20%20Row1%20%3D%20%5BS11%2C%20S12%2C%20S13%2C%20S14%5D%2C%5Cn%20%20Row2%20%3D%20%5BS21%2C%20S22%2C%20S23%2C%20S24%5D%2C%5Cn%20%20Row3%20%3D%20%5BS31%2C%20S32%2C%20S33%2C%20S34%5D%2C%5Cn%20%20Row4%20%3D%20%5BS41%2C%20S42%2C%20S43%2C%20S44%5D%2C%20%20%20%20%20%20%5Cn%20%20%5Cn%20%20Col1%20%3D%20%5BS11%2C%20S21%2C%20S31%2C%20S41%5D%2C%5Cn%20%20Col2%20%3D%20%5BS12%2C%20S22%2C%20S32%2C%20S42%5D%2C%5Cn%20%20Col3%20%3D%20%5BS13%2C%20S23%2C%20S33%2C%20S43%5D%2C%5Cn%20%20Col4%20%3D%20%5BS14%2C%20S24%2C%20S34%2C%20S44%5D%2C%20%20%20%20%20%20%5Cn%20%20%5Cn%20%20Square1%20%3D%20%5BS11%2C%20S12%2C%20S21%2C%20S22%5D%2C%5Cn%20%20Square2%20%3D%20%5BS13%2C%20S14%2C%20S23%2C%20S24%5D%2C%5Cn%20%20Square3%20%3D%20%5BS31%2C%20S32%2C%20S41%2C%20S42%5D%2C%5Cn%20%20Square4%20%3D%20%5BS33%2C%20S34%2C%20S43%2C%20S44%5D%2C%20%20%20%20%20%20%5Cn%20%20%5Cn%20%20valid(%5BRow1%2C%20Row2%2C%20Row3%2C%20Row4%2C%5Cn%20%20%20%20%20%20%20%20%20Col1%2C%20Col2%2C%20Col3%2C%20Col4%2C%5Cn%20%20%20%20%20%20%20%20%20Square1%2C%20Square2%2C%20Square3%2C%20Square4%5D).%5Cn%20%5Cnvalid(%5B%5D).%5Cnvalid(%5BHead%20%7C%20Tail%5D)%20%3A-%20fd_all_different(Head)%2C%20valid(Tail).%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">sudoku(Puzzle,&nbsp;Solution)&nbsp;:-
&nbsp;&nbsp;Solution&nbsp;=&nbsp;Puzzle,
&nbsp;&nbsp;
&nbsp;&nbsp;Puzzle&nbsp;=&nbsp;[S11,&nbsp;S12,&nbsp;S13,&nbsp;S14,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S21,&nbsp;S22,&nbsp;S23,&nbsp;S24,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S31,&nbsp;S32,&nbsp;S33,&nbsp;S34,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S41,&nbsp;S42,&nbsp;S43,&nbsp;S44],
&nbsp;&nbsp;
&nbsp;&nbsp;fd_domain(Solution,&nbsp;1,&nbsp;4),
&nbsp;&nbsp;
&nbsp;&nbsp;Row1&nbsp;=&nbsp;[S11,&nbsp;S12,&nbsp;S13,&nbsp;S14],
&nbsp;&nbsp;Row2&nbsp;=&nbsp;[S21,&nbsp;S22,&nbsp;S23,&nbsp;S24],
&nbsp;&nbsp;Row3&nbsp;=&nbsp;[S31,&nbsp;S32,&nbsp;S33,&nbsp;S34],
&nbsp;&nbsp;Row4&nbsp;=&nbsp;[S41,&nbsp;S42,&nbsp;S43,&nbsp;S44],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;Col1&nbsp;=&nbsp;[S11,&nbsp;S21,&nbsp;S31,&nbsp;S41],
&nbsp;&nbsp;Col2&nbsp;=&nbsp;[S12,&nbsp;S22,&nbsp;S32,&nbsp;S42],
&nbsp;&nbsp;Col3&nbsp;=&nbsp;[S13,&nbsp;S23,&nbsp;S33,&nbsp;S43],
&nbsp;&nbsp;Col4&nbsp;=&nbsp;[S14,&nbsp;S24,&nbsp;S34,&nbsp;S44],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;Square1&nbsp;=&nbsp;[S11,&nbsp;S12,&nbsp;S21,&nbsp;S22],
&nbsp;&nbsp;Square2&nbsp;=&nbsp;[S13,&nbsp;S14,&nbsp;S23,&nbsp;S24],
&nbsp;&nbsp;Square3&nbsp;=&nbsp;[S31,&nbsp;S32,&nbsp;S41,&nbsp;S42],
&nbsp;&nbsp;Square4&nbsp;=&nbsp;[S33,&nbsp;S34,&nbsp;S43,&nbsp;S44],&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;valid([Row1,&nbsp;Row2,&nbsp;Row3,&nbsp;Row4,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Col1,&nbsp;Col2,&nbsp;Col3,&nbsp;Col4,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Square1,&nbsp;Square2,&nbsp;Square3,&nbsp;Square4]).
&nbsp;
valid([]).
valid([Head&nbsp;|&nbsp;Tail])&nbsp;:-&nbsp;fd_all_different(Head),&nbsp;valid(Tail).</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>以下是数独解算器的运行结果：</p><pre data-cke-widget-data="%7B%22code%22%3A%22%7C%20%3F-%20sudoku(%5B_%2C%20_%2C%202%2C%203%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20_%2C%20_%2C%20_%2C%20_%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20_%2C%20_%2C%20_%2C%20_%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%203%2C%204%2C%20_%2C%20_%5D%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20Solution).%5Cn%20%5Cn%20%5CnS%20%3D%20%5B4%2C1%2C2%2C3%2C2%2C3%2C4%2C1%2C1%2C2%2C3%2C4%2C3%2C4%2C1%2C2%5D%22%2C%22classes%22%3Anull%7D" data-cke-widget-upcasted="1" data-cke-widget-keep-attr="0" data-widget="codeSnippet" class="cke_widget_element">|&nbsp;?-&nbsp;sudoku([_,&nbsp;_,&nbsp;2,&nbsp;3,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_,&nbsp;_,&nbsp;_,&nbsp;_,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_,&nbsp;_,&nbsp;_,&nbsp;_,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3,&nbsp;4,&nbsp;_,&nbsp;_],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solution).
&nbsp;
&nbsp;
S&nbsp;=&nbsp;[4,1,2,3,2,3,4,1,1,2,3,4,3,4,1,2]</pre><p><span class="cke_reset cke_widget_drag_handler_container" style="background:rgba(220,220,220,0.5);background-image:url(https://my.oschina.net/dist/www/vendor/ckeditor/4.5.8/plugins/widget/images/handle.png)"></span></p><p>不幸的是，声明式编程语言很容易造成性能瓶颈。上面的排序算法很可能&nbsp;<code>O(n!)</code>让数独解算器进行了一次强力搜索;&nbsp;而且大多数开发人员必须提供数据库提示和额外索引，避免执行SQL查询时出现代价高昂且效率低下的情况。</p><h3>符号编程</h3><p><img alt="" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0309/182731_9rps_3703517.png" src="https://static.oschina.net/uploads/space/2018/0309/182731_9rps_3703517.png"/></p><p>示例语言：</p>
---------------
<h1 id="#title_20" >21、每日一博 | 从零开始写简易读写分离并不复杂</h1>

[https://my.oschina.net/floor/blog/1632565](https://my.oschina.net/floor/blog/1632565)
<p>最近在学习Spring boot，写了个读写分离。并未照搬网文，而是独立思考后的成果，写完以后发现从零开始写读写分离并不难！</p>
---------------
<h1 id="#title_21" >22、五大 JAVA Web 框架的优缺点对比，Spring MVC 领先</h1>

[https://www.oschina.net/news/94081/java-web-frameworks-compare](https://www.oschina.net/news/94081/java-web-frameworks-compare)
<p>毫无疑问，Java 是当今世界上最重要的编程语言之一。js 框架给程序员提供了 一个可以构建程序的坚实基础。它包括定义的类和功能，用于硬件设备管理，与系统软件交互并处理输入，让开发人员变得更轻松。JavaScript 框架旨在支持动态网站，Web服务，Web资源和Web应用程序的开发。在本文中，搜集了 5 个关于Java Web框架的信息。</p><h3>1.Spring MVC - Java Web 框架</h3><p>自离首次发布 10 多年以来，Spring MVC 框架仍然领先于竞争对手。随着时间的推移，它扩展成一个完整的MVC框架，并不断演变成一个全面的Java框架。作为集成特殊应用科学的分层J2EE / Java框架，该框架为软件工程师提供了用于 Web 应用程序配置，应用程序开发和安全项目的完整工具包。该框架以其发达的生态系统而闻名，它提供了许多附加选项，从SOAP Web服务，REST API到安全加密和授权。&nbsp;&nbsp;</p><p><strong>优点：</strong></p><ul class=" list-paddingleft-2"><li><p>增强模块化的轻量级容器</p></li><li><p>可以跨各种平台进行部署</p></li><li><p>灵活的依赖注入使用</p></li><li><p>包括XML，Java和注释配置的三路配置</p></li><li><p>通过POJO&#39;s缓解了注射测试的数据</p></li></ul><p><strong>缺点：</strong></p><ul class=" list-paddingleft-2"><li><p>学习曲线比较陡峭</p></li><li><p>新手实施比较困难</p></li><li><p>需要花费时间部署</p></li></ul><h3>2.JSF - Java Web 框架</h3><p>Oracle 认为 JSF 是一个实用网络 Java 框架，旨在简化基于Web的UI的集成开发。虽然这个框架在Java开发方面不是很好，但是Oracle提供的文档很容易使用。这是一种标准化的技术，拥有丰富的工具和库，可以为你在高度复杂的应用程序中铺平道路。JSF规范允许启用标准用户界面组件的重用和扩展。它减少了创建和维护Java应用程序在服务器上运行和在目标客户端上呈现 UI 应用程序的痛苦。不仅如此，它还提供简单的数据传输和可重用的UI组件。&nbsp;</p><p><strong>优点 &nbsp;</strong></p><ul class=" list-paddingleft-2"><li><p>由于它可以创建可重复使用的组件，因此效率更高且一致</p></li><li><p>支持像EJB这样的JSF实现的优秀供应商（IBM，Oracle，JBoss等）</p></li><li><p>准备使用像Apache，Infragistics，Richfaces等组件</p></li><li><p>方便开发人员，特别是那些使用IDE软件的人</p></li></ul><p><strong>JSF的缺点</strong></p><ul class=" list-paddingleft-2"><li><p>陡峭的学习曲线</p></li><li><p>没有考虑书签工具</p></li><li><p>不可扩展</p></li><li><p>原始Ajax支持</p></li><li><p>缺乏灵活性</p></li></ul><h3>3.Google Web Toolkit - Java Web 框架</h3><p>Google Web Toolkit（GWT）是一个开源开发工具集，使开发人员能够构建和优化复杂的JS前端应用程序。它的主要目标是提供高性能Web应用程序的开发，即使开发人员不熟悉 JavaScript，XMLHttpRequest 或浏览器等偏冷门的知识。为了让其可信度高，谷歌自己的许多产品，包括 AdSense，Hotel Finder，Wallet，AdWords 等都使用 GWT。 &nbsp;&nbsp;&nbsp;&nbsp;</p><p><strong>优点：</strong></p><ul class=" list-paddingleft-2"><li><p>更容易学习</p></li><li><p>内置IDE支持重构Java代码</p></li><li><p>可以在客户端大量构建响应式Web应用程序，并减少服务器端的琐事</p></li><li><p>可以迭代地平滑地从典型的Web应用程序迁移到GWT应用程序</p></li><li><p>即使在使用AJAX的情况下，也具有内置的浏览器后退按钮支持</p></li></ul><p><strong>缺点：</strong></p><ul class=" list-paddingleft-2"><li><p>仅对Java开发人员有利，对PHP或.NET的开发人员没有太大帮助</p></li><li><p>由于快速发展的GWT，有许多版本很难获得所有功能和接口</p></li><li><p>编译速度慢，需要使用专有方法来定义结构</p></li></ul><h3>4.Grails - Java Web 框架</h3><p>Grails 是一个开源的Java Web框架，旨在将开发人员的生产力与默认值和Convention-over-Configuration API相提并论。它与Java虚拟机（JVM）相集成，同时提供强大的功能，包括编译时元编程，异步编程和领域特定语言。Grails采用强大的视图技术，集成的NoSQL / ORM支持，插件和Spring支持的依赖注入进行更新。让你可以轻松集成并互操作Java，Java EE和JVM容器。&nbsp;</p><p><strong>优点：</strong></p><ul class=" list-paddingleft-2"><li><p>Grails提供了一个快速的开发周期</p></li><li><p>非常适合小型和中型项目</p></li><li><p>各种插件可供选择</p></li><li><p>简单而令人易懂的文档</p></li><li><p>可以在不重启服务器的情况下更改配置</p></li></ul><p><strong>缺点：</strong></p><ul class=" list-paddingleft-2"><li><p>使用运行时语言可能会很困难</p></li><li><p>开发多线程应用程序，GORM 可能会出现问题</p></li><li><p>复杂的集成过程</p></li><li><p>延迟运行时间</p></li></ul><h3>5.Struts 2 - Java Web框架</h3><p>Apache的Struts是一个用于开发现代Java Web应用程序的开源免费MVC框架。它包含一组类和接口，共同协作开发Web应用程序。它适用于许多Java应用程序的网络框架，并且受到了很多社区的支持。为了进一步扩展Struts Java框架，Struts 2 作为后继者有了很大的改变。这个框架最适合于开发当代 Java EE web 应用程序的工程师，Apache 软件基金会借助 Struts 2 为开发人员提供了一个用于开发面向网络的，企业级应用程序，并优化整个开发流程的工具。</p><p><strong>优点：</strong></p><ul class=" list-paddingleft-2"><li><p>没有线程安全问题</p></li><li><p>依赖注入使得测试更简单</p></li><li><p>它可以使用“对象图导航语言”（OGNL）</p></li><li><p>Struts 2框架的Servlet上下文以简单的地图形式表示&nbsp;</p></li><li><p>它支持通过验证方法进行手动验证，并且还包含子框架验证</p></li></ul><p><strong>缺点：</strong></p><ul class=" list-paddingleft-2"><li><p>由于它与Struts 1完全不同，难以迁移</p></li><li><p>Struts 2 文档非常有限</p></li><li><p>由于文档管理不善，新用户很难发现它的优点</p></li></ul><p>来自：</p>
---------------
<h1 id="#title_22" >23、文章： 敏捷规划时间表</h1>
Leigh Koetter
[http://www.infoq.com/cn/articles/planned-agile-schedule?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/planned-agile-schedule?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/planned-agile-schedule/zh/headerimage/GettyImages-537468878-2-1518258442171.jpg"/><p>敏捷规划时间表可以用来协调敏捷方法论和软件固定上线日期之间的冲突，从而可视化展示项目计划进度，使用敏捷方法在一个比较高的层次控制项目，作为可量化的高层次交付的挽具，协调项目活动，并强化有效沟通。</p> <i>By Leigh Koetter</i> <i> Translated by 张健欣</i>
---------------
<h1 id="#title_23" >24、OSChina 周日乱弹 —— 爱丽丝爱吃京酱肉丝</h1>

[https://my.oschina.net/xxiaobian/blog/1632867](https://my.oschina.net/xxiaobian/blog/1632867)
<p>钱不知所终，都去哪儿了，买吃的了呗！</p>
---------------
<h1 id="#title_24" >25、Google 意图让 AMP 网页快速载入技术成为标准</h1>

[https://www.oschina.net/news/94078/google-pushes-for-amp-based-technology-as-standard](https://www.oschina.net/news/94078/google-pushes-for-amp-based-technology-as-standard)
<p>Google 在关于加速移动页面项目的公告中，透露了未来推出这些 Web 标准的计划。借由 AMP 的经验和技术，开发可以让非 AMP 网页内容即时加载的 Web 标准。这意味着非 AMP 的网页都可以获得与 AMP 相同的效果：近乎瞬时的加载，兼容多个平台等。</p><p>Accelerated Mobile Pages（AMP）是由 Google 发起的一个开源网页技术，旨在提供工具，加速移动网站的载入，并减少流量。不过，目前为止应用的网站并不多（主要就是 Google 自己、Twitter、Bing 和百度），让 Google 无法扩大自己这套系统的影响力。在现在这个还没有哪一家的技术占据市场的时代，Google 希望能先于&nbsp;Facebook 的 Instant Articles&nbsp;等独家的格式，因此正准备提案，让 AMP 成为业界标准。<br/><br/>当然，公开意图是一回事，到 AMP 真的被采纳为标准，还要经过 WWWC 等多个国际标准组织的认可，天知道还要几年的时间。在这期间，Google 也没有打算停下技术的开发，将会继续深化搜索技术与内容间的关连性，并且对 AMP 上的电子商务进行针对性的升级。终究，Google 的利益在于让你留在「一般」的网页上，而不是被关进某些 app 的花园当中，但究竟最后是哪一方胜出，就还要再看未来的发展啰。</p><p>来自：</p>
---------------
<h1 id="#title_25" >26、视频演讲： UC浏览器容器化架构演进之路</h1>
顾辉
[http://www.infoq.com/cn/presentations/the-evolution-of-the-uc-browser-container-architecture?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/the-evolution-of-the-uc-browser-container-architecture?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/presentations/the-evolution-of-the-uc-browser-container-architecture/zh/mediumimage/guhui270-1517042198295.jpg"/><p>整个演讲内容分为4个主要方向：

1.UC浏览器分为国内版和国际版，那么App架构如何同时支撑国内，国际多个版本的快速迭代？构建系统做了哪些支持？在演讲过程中，会谈到能够满足一致需求及一致性能稳定性要求的架构解决方案，如容器化解决方案等。

2.UC有自己的内核团队，专注内核模块的开发，同时作为一个内容的综合入口，提供了搜索、小说、漫画、头条等业务功能，而要实现数百号人团队高效运作，这其中的挑战非常多。

3.随着移动互联网的发展，容器化、业务内容化、精细化运营成为大的趋势，UC是通过什么样的技术手段保证高效运营的？

4.随着React Native以及Weex这样的跨平台技术的出现，PWA这样技术的出现，以及网络状态逐步优化，前端和客户端的边界越来越模糊，作为能做Web内核优化的团队，我们在布局大前端的融合。</p> <i>By 顾辉</i>
---------------
<h1 id="#title_26" >27、7-Zip 18.03 beta 发布，数据压缩程序</h1>

[https://www.oschina.net/news/94075/7-zip-18-03-beta](https://www.oschina.net/news/94075/7-zip-18-03-beta)
<p>7-Zip 18.03 beta 发布了。7-Zip是一个开放源码的数据压缩程序，主要用在Microsoft Windows操作系统，Unix-like的操作系统如Linux与FreeBSD下面有7-zip的移植版本p7zip可以使用。它提供命令行接口的程序或图形用户界面的程序，而且可以与资源管理器结合。</p><p>主要更新内容：<br/></p><ul class=" list-paddingleft-2"><li><p>The speed for single-thread LZMA/LZMA2 decoding was increased&nbsp; by 30% in x64 version and by 3% in x86 version.</p></li><li><p>7-Zip now can use multi-threading for 7z/LZMA2 decoding, if there are multiple independent data chunks in LZMA2 stream.</p></li></ul><p>下载地址：<br/></p><ul class=" list-paddingleft-2"><li><p>&nbsp;</p></li></ul>
---------------