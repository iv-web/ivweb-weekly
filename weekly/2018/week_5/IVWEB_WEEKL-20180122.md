## 文章索引
1、 <a href="#1nodemailer-442-发布nodejs-邮件发送组件" >Nodemailer 4.4.2 发布，Node.js 邮件发送组件</a><br/>
2、 <a href="#2plotlyjs-1330-发布javascript-图表库" >Plotly.js 1.33.0 发布，JavaScript 图表库</a><br/>
3、 <a href="#3inquirerjs-v501-发布交互式命令行用户界面集合" >Inquirer.js v5.0.1 发布，交互式命令行用户界面集合</a><br/>
4、 <a href="#4chakracore-180-发布微软-edge-浏览器-js-引擎" >ChakraCore 1.8.0 发布，微软 Edge 浏览器 JS 引擎</a><br/>
5、 <a href="#5autoplaywechatjumpgame-微信跳一跳自动机器人" >AutoPlayWechatJumpGame — 微信跳一跳自动机器人</a><br/>
6、 <a href="#6汇编语言入门教程" >汇编语言入门教程</a><br/>
7、 <a href="#7cocoapods-140-发布xcode-依赖库管理" >CocoaPods 1.4.0 发布，Xcode 依赖库管理</a><br/>
8、 <a href="#8dbeaver-433-发布数据库管理工具" >DBeaver 4.3.3 发布，数据库管理工具</a><br/>
9、 <a href="#9ant-design-314-发布阿里企业级-ui-设计语言" >Ant Design 3.1.4 发布，阿里企业级 UI 设计语言</a><br/>
10、 <a href="#10wekan-064-发布基于-meteor-的看板管理应用" >Wekan 0.64 发布，基于 Meteor 的看板管理应用</a><br/>
11、 <a href="#11chatterbot-082-发布python-聊天机器人框架" >ChatterBot 0.8.2 发布，Python 聊天机器人框架</a><br/>
12、 <a href="#12hikyuu-108-发布量化交易研究框架" >Hikyuu 1.0.8 发布，量化交易研究框架</a><br/>
13、 <a href="#13rdoc-132-发布只需写-markdown-即可生成网站" >RDoc 1.3.2 发布，只需写 Markdown 即可生成网站</a><br/>
14、 <a href="#14loading-cli-106-发布命令行-loading-效果" >loading-cli 1.0.6 发布，命令行 loading 效果</a><br/>
15、 <a href="#15fiery-0562-beta-发布php-性能跟踪监控系统" >Fiery 0.5.6.2-beta 发布，PHP 性能跟踪监控系统</a><br/>
16、 <a href="#16luascriptcore-v210-发布移动端-lua-桥接框架" >LuaScriptCore v2.1.0 发布，移动端 Lua 桥接框架</a><br/>
17、 <a href="#17协作翻译-|-一些文本编辑器的实用技巧和经验分享" >协作翻译 | 一些文本编辑器的实用技巧和经验分享</a><br/>
18、 <a href="#18jiaozivideoplayer-v625-发布视频播放控件" >JiaoZiVideoPlayer v6.2.5 发布，视频播放控件</a><br/>
19、 <a href="#19码云推荐-|-php-接入实现百度文字和图像识别-baiduocr" >码云推荐 | PHP 接入实现百度文字和图像识别 BaiduOcr</a><br/>
20、 <a href="#20每日一博-|-五年架构师讲述-restful-架构风格" >每日一博 | 五年架构师讲述 RESTful 架构风格</a><br/>
21、 <a href="#21mozilla-承诺firefox-58-将带来意想不到的速度" >Mozilla 承诺：Firefox 58 将带来意想不到的速度</a><br/>
22、 <a href="#22全球-100-强技术公司排行榜微软打败谷歌成为第一巨头" >全球 100 强技术公司排行榜：微软打败谷歌成为第一巨头</a><br/>
23、 <a href="#2322-岁的-google-工程师发现了震惊科技界的-cpu-漏洞" >22 岁的 Google 工程师：发现了震惊科技界的 CPU 漏洞</a><br/>
24、 <a href="#24oschina-周日乱弹-程序员的好日子什么时候才到头" >OSChina 周日乱弹 ——程序员的好日子什么时候才到头？</a><br/>
25、 <a href="#25根据-dice-和-linux-基金会调查来看看国外开源人员现状" >根据 Dice 和 Linux 基金会调查：来看看国外开源人员现状</a><br/>
26、 <a href="#26谷歌-ceo-表示比编程能力更重要的是持续学习" >谷歌 CEO 表示：比编程能力更重要的是持续学习</a><br/>
27、 <a href="#27lerna-v280-发布多包存储库管理工具" >Lerna v2.8.0 发布，多包存储库管理工具</a><br/>
28、 <a href="#28文章-开发者需要知道的有关软件架构的五件事" >文章： 开发者需要知道的有关软件架构的五件事</a><br/>
29、 <a href="#29文章-阿里盒马领域驱动设计实践" >文章： 阿里盒马领域驱动设计实践</a><br/>
30、 <a href="#30文章-p2p如何将视频直播带宽降低75" >文章： P2P如何将视频直播带宽降低75%？</a><br/>
31、 <a href="#31视频演讲-freewheel-olap实践" >视频演讲： FreeWheel OLAP实践</a><br/>
32、 <a href="#32视频演讲-全链路稳定性背后的数字化支撑阿里巴巴鹰眼技术解密" >视频演讲： 全链路稳定性背后的数字化支撑：阿里巴巴鹰眼技术解密</a><br/>
33、 <a href="#33视频演讲-深度学习在视频重复检测中的实践" >视频演讲： 深度学习在视频重复检测中的实践</a><br/>
34、 <a href="#34视频演讲-ai技术落地工业打造无忧工业理想未来" >视频演讲： AI技术落地工业，打造无忧工业理想未来</a><br/><h1 id="#title_0" >1、Nodemailer 4.4.2 发布，Node.js 邮件发送组件</h1>

[https://www.oschina.net/news/92634/nodemailer-4-4-2](https://www.oschina.net/news/92634/nodemailer-4-4-2)
<p>Nodemailer 4.4.2 已发布，该版本在文档中添加了赞助者信息，并将 encodeURIComponent&nbsp; 封装进&nbsp;try..catch&nbsp; 中以处理无效的 URL 。</p></li></ul>
---------------
<h1 id="#title_1" >2、Plotly.js 1.33.0 发布，JavaScript 图表库</h1>

[https://www.oschina.net/news/92639/plotlyjs-1-33-0](https://www.oschina.net/news/92639/plotlyjs-1-33-0)
<p>Plotly.js 是开源的 JavaScript 图表库，它基于 d3.js 和&nbsp;stack.gl&nbsp;。是一个高层次的、描述性的图表库。 plotly.js 带来20种图表类型，包括 3D 图表，统计图表，和 SVG 地图。</p><p>Plotly.js 1.33.0&nbsp;部分更新内容如下：</p><ul class=" list-paddingleft-2"><li><p>使用 regl 完全重写 scattergl trace 类型</p></li><li><p>完全重写极坐标图渲染器</p></li><li><p>新增使用散点图跟踪布局图像和布局形状的功能</p></li><li><p>新增 spikedistance，hoverdistance 和 skipsnap 以便更好地定制笛卡尔子图</p></li><li><p>添加官方西班牙语翻译</p></li><li><p>添加官方法文翻译</p></li><li><p>一些旧的极坐标轨迹类型已不推荐使用</p></li><li><p>……</p></li></ul><p>完整更新内容请查阅</p></li></ul>
---------------
<h1 id="#title_2" >3、Inquirer.js v5.0.1 发布，交互式命令行用户界面集合</h1>

[https://www.oschina.net/news/92636/inquirerjs-5-0-1](https://www.oschina.net/news/92636/inquirerjs-5-0-1)
<p>Inquirer.js&nbsp;v5.0.1&nbsp;已发布，修复了&nbsp;<code>editor</code>&nbsp;的提示&nbsp;bug 。</p></li></ul>
---------------
<h1 id="#title_3" >4、ChakraCore 1.8.0 发布，微软 Edge 浏览器 JS 引擎</h1>

[https://www.oschina.net/news/92617/chakracore-1-8-0](https://www.oschina.net/news/92617/chakracore-1-8-0)
<p>ChakraCore 是微软开源的 Microsoft Edge 浏览器 Chakra JavaScript 引擎的核心部分，主要用于 Microsoft Edge 和 Windows 中 HTML/CSS/JavaScript 编写的应用。</p><p><img height="459" data-cke-saved-src="https://static.oschina.net/uploads/space/2017/0728/154416_KaQj_2896879.png" src="https://static.oschina.net/uploads/space/2017/0728/154416_KaQj_2896879.png" width="575"/></p><p>ChakraCore 1.8.0&nbsp;包含一些 JavaScript 和 WebAssembly&nbsp;相关的功能更新和性能改进，部分亮点如下：</p><ul class=" list-paddingleft-2"><li><p></p></li></ul>
---------------
<h1 id="#title_4" >5、AutoPlayWechatJumpGame — 微信跳一跳自动机器人</h1>

[https://www.oschina.net/p/autoplaywechatjumpgame](https://www.oschina.net/p/autoplaywechatjumpgame)
<p>自动玩微信跳一跳游戏Java版，仅供技术研究使用，请勿用于非法用途。</p>
---------------
<h1 id="#title_5" >6、汇编语言入门教程</h1>
阮一峰
[http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html](http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html)
<p>学习编程其实就是学高级语言，即那些为人类设计的计算机语言。</p>

        <p>但是，计算机不理解高级语言，必须通过编译器转成二进制代码，才能运行。学会高级语言，并不等于理解计算机实际的运行步骤。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012204.png" alt="" title="" /></p>

<p>计算机真正能够理解的是低级语言，它专门用来控制硬件。汇编语言就是低级语言，直接描述/控制 CPU 的运行。如果你想了解 CPU 到底干了些什么，以及代码的运行步骤，就一定要学习汇编语言。</p>

<p>汇编语言不容易学习，就连简明扼要的介绍都很难找到。下面我尝试写一篇最好懂的汇编语言教程，解释 CPU 如何执行代码。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012202.jpg" alt="" title="" /></p>

<h2>一、汇编语言是什么？</h2>

<p>我们知道，CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。</p>

<p>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是<code>00000011</code>。的作用，就是将高级语言写好的程序，翻译成一条条操作码。</p>

<p>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012203.jpg" alt="" title="" /></p>

<p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>

<h2>二、来历</h2>

<p>最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。</p>

<p>为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。</p>

<p>这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。它处理的文本，自然就叫做 aseembly code。标准化以后，称为 assembly language，缩写为 asm，中文译为汇编语言。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012205.jpg" alt="" title="" /></p>

<p>每一种 CPU 的机器指令都是不一样的，因此对应的汇编语言也不一样。本文介绍的是目前最常见的 x86 汇编语言，即 Intel 公司的 CPU 使用的那一种。</p>

<h2>三、寄存器</h2>

<p>学习汇编语言，首先必须了解两个知识点：寄存器和内存模型。</p>

<p>先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>

<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012206.png" alt="" title="" /></p>

<p>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p>

<h2>四、寄存器的种类</h2>

<p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p>

<blockquote>
  <ul>
<li>EAX</li>
<li>EBX</li>
<li>ECX</li>
<li>EDX</li>
<li>EDI</li>
<li>ESI</li>
<li>EBP</li>
<li>ESP</li>
</ul>
</blockquote>

<p>上面这8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012207.png" alt="" title="" /></p>

<p>我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。</p>

<h2>五、内存模型：Heap</h2>

<p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p>

<p>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012208.png" alt="" title="" /></p>

<p>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012209.png" alt="" title="" /></p>

<p>这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。它由起始地址开始，从低位（地址）向高位（地址）增长。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>

<h2>六、内存模型：Stack</h2>

<p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012210.png" alt="" title="" /></p>

<p>请看下面的例子。</p>

<blockquote><pre><code class="language-clike">
int main() {
   int a = 2;
   int b = 3;
}
</code></pre></blockquote>

<p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012211.png" alt="" title="" /></p>

<p>如果函数内部调用了其他函数，会发生什么情况？</p>

<blockquote><pre><code class="language-clike">
int main() {
   int a = 2;
   int b = 3;
   return add_a_and_b(a, b);
}
</code></pre></blockquote>

<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012212.png" alt="" title="" /></p>

<p>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>

<p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做"入栈"，英文是 push；栈的回收叫做"出栈"，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做"后进先出"的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012213.jpg" alt="" title="" /></p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012214.jpg" alt="" title="" /></p>

<p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012215.png" alt="" title="" /></p>

<h2>七、CPU 指令</h2>

<h3>7.1 一个实例</h3>

<p>了解寄存器和内存模型以后，就可以来看汇编语言到底是什么了。下面是一个简单的程序<code>example.c</code>。</p>

<blockquote><pre><code class="language-clike">
int add_a_and_b(int a, int b) {
   return a + b;
}

int main() {
   return add_a_and_b(2, 3);
}
</code></pre></blockquote>

<p>gcc 将这个程序转成汇编语言。</p>

<blockquote><pre><code class="language-bash">
$ gcc -S example.c
</code></pre></blockquote>

<p>上面的命令执行以后，会生成一个文本文件<code>example.s</code>，里面就是汇编语言，包含了几十行指令。这么说吧，一个高级语言的简单操作，底层可能由几个，甚至几十个 CPU 指令构成。CPU 依次执行这些指令，完成这一步操作。</p>

<p><code>example.s</code>经过简化以后，大概是下面的样子。</p>

<blockquote><pre><code class="language-clike">
_add_a_and_b:
   push   %ebx
   mov    %eax, [%esp+8] 
   mov    %ebx, [%esp+12]
   add    %eax, %ebx 
   pop    %ebx 
   ret  

_main:
   push   3
   push   2
   call   _add_a_and_b 
   add    %esp, 8
   ret
</code></pre></blockquote>

<p>可以看到，原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。</p>

<p>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p>

<blockquote><pre><code class="language-clike">
push   %ebx
</code></pre></blockquote>

<p>这一行里面，<code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p>

<p>下面我就一行一行讲解这个汇编程序，建议读者最好把这个程序，在另一个窗口拷贝一份，省得阅读的时候再把页面滚动上来。</p>

<h3>7.2 push 指令</h3>

<p>根据约定，程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。</p>

<p>然后，开始执行第一行代码。</p>

<blockquote><pre><code class="language-clike">
push   3
</code></pre></blockquote>

<p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。</p>

<p>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节。</p>

<blockquote><pre><code class="language-clike">
push   2
</code></pre></blockquote>

<p>第二行也是一样，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2018/bg2018012216.png" alt="" title="" /></p>

<h3>7.3 call 指令</h3>

<p>第三行的<code>call</code>指令用来调用函数。</p>

<blockquote><pre><code class="language-clike">
call   _add_a_and_b
</code></pre></blockquote>

<p>上面的代码表示调用<code>add_a_and_b</code>函数。这时，程序就会去找<code>_add_a_and_b</code>标签，并为该函数建立一个新的帧。</p>

<p>下面就开始执行<code>_add_a_and_b</code>的代码。</p>

<blockquote><pre><code class="language-clike">
push   %ebx
</code></pre></blockquote>

<p>这一行表示将 EBX 寄存器里面的值，写入<code>_add_a_and_b</code>这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。</p>

<p>这时，<code>push</code>指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。</p>

<h3>7.4 mov 指令</h3>

<p><code>mov</code>指令用于将一个值写入某个寄存器。</p>

<blockquote><pre><code class="language-clike">
mov    %eax, [%esp+8] 
</code></pre></blockquote>

<p>这一行代码表示，先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是<code>2</code>，再将<code>2</code>写入 EAX 寄存器。</p>

<p>下一行代码也是干同样的事情。</p>

<blockquote><pre><code class="language-clike">
mov    %ebx, [%esp+12] 
</code></pre></blockquote>

<p>上面的代码将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是<code>3</code>，将其写入 EBX 寄存器。</p>

<h3>7.5 add 指令</h3>

<p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。</p>

<blockquote><pre><code class="language-clike">
add    %eax, %ebx
</code></pre></blockquote>

<p>上面的代码将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。</p>

<h3>7.6 pop 指令</h3>

<p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。</p>

<blockquote><pre><code class="language-clike">
pop    %ebx
</code></pre></blockquote>

<p>上面的代码表示，取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器（因为加法已经做完了，EBX 寄存器用不到了）。</p>

<p>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。</p>

<h3>7.7 ret 指令</h3>

<p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。</p>

<blockquote><pre><code class="language-clike">
ret
</code></pre></blockquote>

<p>可以看到，该指令没有运算子。</p>

<p>随着<code>add_a_and_b</code>函数终止执行，系统就回到刚才<code>main</code>函数中断的地方，继续往下执行。</p>

<blockquote><pre><code class="language-clike">
add    %esp, 8 
</code></pre></blockquote>

<p>上面的代码表示，将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。</p>

<blockquote><pre><code class="language-clike">
ret
</code></pre></blockquote>

<p>最后，<code>main</code>函数运行结束，<code>ret</code>指令退出程序执行。</p>

<h2>八、参考链接</h2>

<ul>
<li>, by Youness Alaoui</li>
<li>, by University of Virginia Computer Science</li>
</ul>

<p>（完）</p>

        <div style="color:#556677;line-height:160%;padding:0.3em 0.5em;border:1px solid #d3d3d3;margin:1em;background-color:#AAD2F0;-moz-border-radius: 10px;-webkit-border-radius:10px;border-radius: 10px;"><h3>文档信息</h3>
<ul>
<li>版权声明：自由转载-非商用-非衍生-保持署名（）</li>
<li>发表日期： <abbr class="published" title="2018-01-21T18:17:48+08:00">2018年1月21日</abbr></li>
<li>更多内容：   » 
 
</li>
<li>文集：</li>
<li>社交媒体：</li>

</ul></div>        
        <div style="color:#556677;line-height:160%;padding:0.3em 0.5em;margin:1em;-moz-border-radius: 10px;-webkit-border-radius:10px;border-radius: 10px;"></div>
---------------
<h1 id="#title_6" >7、CocoaPods 1.4.0 发布，Xcode 依赖库管理</h1>

[https://www.oschina.net/news/92638/cocoapods-1-4-0](https://www.oschina.net/news/92638/cocoapods-1-4-0)
<p>CocoaPods 1.4.0&nbsp;已发布，更新内容如下：</p><p>改进</p><ul class=" list-paddingleft-2"><li><p>当 Pod source 使用的是未加密的 HTTP 时，显示警告</p></li></ul><p>修复</p><ul class=" list-paddingleft-2"><li><p>不再将测试规范资源和依赖目标的框架路径包含到测试脚本中</p></li><li><p>在安装程序中恢复 development_pod_targets 公共方法</p></li><li><p>Fix resolution when multiple sources provide the same pods, and there are (potential) dependencies between the sources.&nbsp;</p></li><li><p>Ensure that externally-sourced (e.g. local &amp; git) pods are allowed to resolve to prerelease versions.</p></li></ul><p>更多详情可查阅</p></li></ul>
---------------
<h1 id="#title_7" >8、DBeaver 4.3.3 发布，数据库管理工具</h1>

[https://www.oschina.net/news/92637/dbeaver-4-3-3](https://www.oschina.net/news/92637/dbeaver-4-3-3)
<p>DBeaver 是一个通用的数据库管理工具和 SQL 客户端，支持 MySQL, PostgreSQL, Oracle, DB2, MSSQL, Sybase, Mimer, HSQLDB, Derby, 以及其他兼容 JDBC 的数据库。</p><p>DBeaver 4.3.3 更新内容：</p><ul class=" list-paddingleft-2"><li><p>SQL editor: query extraction was fixed (trailing delimiter)</p></li><li><p>SQL editor: variables support was added (${varName}, configurable)</p></li><li><p>SQL editor: embedded mode was fixed (UI freeze on editor refresh)</p></li><li><p>Results viewer: column drop-down filter was added</p></li><li><p>Numeric cell value dialog editor was fixed</p></li><li><p>Ref cursor cell value dialog viewer was fixed</p></li><li><p>Main toolbar was fixed (now it is visible only in DBeaver perspective)</p></li><li><p>UI of checkbox inline editor was fixed</p></li><li><p>Environment variables substitution now works for all network configurations</p></li><li><p>External Eclipse extension installer was fixed</p></li><li><p>Git integration was implemented with Eclipse Git plugin</p></li><li><p>External plugin repository list was enhanced (Office, SVG, Git, Eclipse Oxygen)</p></li><li><p>Command line support was fixed (-con + connection properties)</p></li><li><p>CSV export: value quoting config was added</p></li><li><p>PostgreSQL: syntax highlighting was improved</p></li><li><p>MariaDB: default column value editor was fixed</p></li><li><p>SQL Server: schema list reading was fixed</p></li><li><p>SQL Server: procedures source reading was fixed</p></li><li><p>Oracle: view definition (truncated) reading was fixed</p></li><li><p>Sybase: error handling was fixed (for queries with multiple results)</p></li><li><p>Firebird: 3.x driver configuration was fixed (default encoding is UTF-8)</p></li><li><p>Windows installer was improved</p></li><li><p>“All Users” mode was removed</p></li><li><p>/S and /D options were fixed</p></li><li><p>Controls internationalization was improved</p></li><li><p>Chinese, Russian and French localizations were improved</p></li><li><p>Many minor UI fixes</p></li></ul><p>下载地址：<br/></p><ul class=" list-paddingleft-2"><li><p></p></li></ul>
---------------
<h1 id="#title_8" >9、Ant Design 3.1.4 发布，阿里企业级 UI 设计语言</h1>

[https://www.oschina.net/news/92642/ant-design-3-1-4](https://www.oschina.net/news/92642/ant-design-3-1-4)
<p>Ant Design 3.1.4 已发布，Ant Design 是蚂蚁金服开发和正在使用的一套企业级的前端设计语言和基于 React 的前端框架实现。</p><p>该版本更新如下：</p><ul class=" list-paddingleft-2"><li><p>修复 ButtonGroup 错误 z-index 导致的样式问题。</p></li><li><p>修复 Dropdown.Button 不能被完全禁用的问题。</p></li><li><p>修复 Layout 错误的响应式相关文档。</p></li><li><p>修复 List&nbsp;<code>grid</code>&nbsp;不支持 xxl 配置的问题。</p></li><li><p>修复 RangePicker 关闭选择面板之后无法清空已选开始时间的问题。</p></li><li><p>修复 Tabs 错误外边距导致的样式问题。</p></li><li><p>修复 WeekPicker 显示错误周数的问题。</p></li><li><p>修复 TypeScript 定义</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>补充 Menu 缺失的&nbsp;<code>subMenuCloseDelay</code>&nbsp;和&nbsp;<code>subMenuOpenDelay</code>。</p></li><li><p>重构了 DatePicker 相关 type 定义。</p></li><li><p>修复了 Input&nbsp;<code>maxLength</code>&nbsp;type 定义。</p></li></ul><li><p>新增 less 变量</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>Checkbox 和 Radio 相关：</p></li></ul>
---------------
<h1 id="#title_9" >10、Wekan 0.64 发布，基于 Meteor 的看板管理应用</h1>

[https://www.oschina.net/news/92635/wekan-0-64](https://www.oschina.net/news/92635/wekan-0-64)
<p>Wekan 是模仿 Trello 且最接近其的开源 KanBan 管理应用，它的前端后端都是用 JavaScript 写的，基于 Meteor 框架。Wekan 简化界面、支持中文、拒绝其他花哨的功能。项目管理所需的标签、注释、添加成员等功能Wekan都有，而且它还有一个免费托管的demo站点，你除了可以下载安装使用外，也可以将Wekan通过Dockerfile镜像在一个容器里安全运行。<br/></p><p>Wekan 0.64 新增了以下新特性：<br/></p><ul class=" list-paddingleft-2"><li><p></p></li></ul>
---------------
<h1 id="#title_10" >11、ChatterBot 0.8.2 发布，Python 聊天机器人框架</h1>

[https://www.oschina.net/news/92641/chatterbot-0-8-2](https://www.oschina.net/news/92641/chatterbot-0-8-2)
<p>ChatterBot 是一个 Python 库，用于简化聊天机器人的开发。ChatterBot 使用不同的机器学习算法来生成不同的响应内容。</p><p>示例对话：</p><pre>user:&nbsp;Good&nbsp;morning!&nbsp;How&nbsp;are&nbsp;you&nbsp;doing?
bot:&nbsp;&nbsp;I&nbsp;am&nbsp;doing&nbsp;very&nbsp;well,&nbsp;thank&nbsp;you&nbsp;for&nbsp;asking.
user:&nbsp;You&#39;re&nbsp;welcome.
bot:&nbsp;&nbsp;Do&nbsp;you&nbsp;like&nbsp;hats?</pre><p>ChatterBot 0.8.2&nbsp;更新内容如下：</p><ul class=" list-paddingleft-2"><li><p>The time logic adapter can now take&nbsp;<code>positive</code>&nbsp;and&nbsp;<code>negative</code>&nbsp;parameters for custom data&nbsp;</p></li></ul>
---------------
<h1 id="#title_11" >12、Hikyuu 1.0.8 发布，量化交易研究框架</h1>

[https://www.oschina.net/news/92633/hikyuu-1-0-8-released](https://www.oschina.net/news/92633/hikyuu-1-0-8-released)
<p><strong>Hikyuu 1.0.8 已发布，这是一款量化交易研究框架。该版本更新如下：</strong></p><p>1、实现一个简单资产组合回测框架 PF_Simple（多标的、相同策略），因目标是多标的、多策略的资产组合框架，所以后续接口可能变化！<br/>2、新增固定列表选择器 SE_Fixed 配合 PF_Simple 使用。<br/>3、新增一个固定持仓天数的盈利目标策略 PG_FixedHoldDays。<br/>4、Datetime增加 dayOfWeek、dayOfYear、endOfMonth 方法。<br/>5、System增加 ev_open_position、cn_open_position参数，控制是否使用环境判断和系统有效性策略作为建仓信号，默认为False。<br/>6、资金管理策略（MoneyManagerBase)加入公共参数disable_ev_force_clean_position、disable_cn_force_clean_position，控制是否禁用市场环境及系统条件强制清仓。<br/>7、资金管理策略（MoneyManagerBase）中，获取买入/卖出数量接口中增加系统来源组件参数。<br/>8、所有系统策略组件clone方法增加保护，在子类clone失败时返回自身。<br/>9、合入网友哥本哈斯根反馈的复权修改。<br/>10、matplotlib调整默认绘图窗口大小。<br/>11、解决echarts绘制macd缺失缩放的问题。<br/>12、TradeManager缺失引出currentCash函数至python。<br/>13、MoneyManager缺失引出getTM函数至python。</p><p>Hikyuu 是一款基于 C++/Python 的开源量化交易研究框架，用于策略分析及回测（目前用于国内股票市场）。与其他量化平台或回测软件相比，其独特性在于：将完整的策略分解为不同的组件，通过重用不同的方面策略，最大化的减轻编写策略的负担，如常见的止损和资金管理策略，只需要简单指定已有的止损或资金管理策略等，即可完成不同的策略组合；同时，可自由遍历所有股票，对策略效果进行综合的统计分析。如下面的示例，简单更好不同的资金管理策略。</p>
---------------
<h1 id="#title_12" >13、RDoc 1.3.2 发布，只需写 Markdown 即可生成网站</h1>

[https://www.oschina.net/news/92631/rdoc-1-3-2](https://www.oschina.net/news/92631/rdoc-1-3-2)
<p>RDoc 1.3.2 发布，这是一款基于 React 的文档生成工具。</p><p><img data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0121/224650_dFlg_811064.png" src="https://static.oschina.net/uploads/space/2018/0121/224650_dFlg_811064.png" alt="" width="600" height="403" border="0" hspace="0" vspace="0" title="" style="width: 600px; height: 403px;"/><br/></p><p>主要用于快速生成文档工具或简单的网站，只需要写&nbsp;Markdown&nbsp;文件即可。</p><p>RDoc&nbsp;1.3.2更新内容：<br/></p><ul class=" list-paddingleft-2"><li><p>npm 忽略.rdoc-dist目录上传。&nbsp;</p></li></ul>
---------------
<h1 id="#title_13" >14、loading-cli 1.0.6 发布，命令行 loading 效果</h1>

[https://www.oschina.net/news/92630/loading-cli-1-0-6](https://www.oschina.net/news/92630/loading-cli-1-0-6)
<p>loading-cli 1.0.6 发布，命令行loading效果。</p><p><img data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0121/210148_nNf1_811064.gif" src="https://static.oschina.net/uploads/space/2018/0121/210148_nNf1_811064.gif" alt=""/></p><p><img alt="" data-cke-saved-src="https://github.com/jaywcjlove/colors-cli/raw/master/img/screenshot.png" src="https://github.com/jaywcjlove/colors-cli/raw/master/img/screenshot.png" style="width: 600px; height: 87px;"/><br/></p><h4>更新内容</h4><ul class=" list-paddingleft-2"><li><p>&nbsp;- 修复参数frames无效.</p></li></ul>
---------------
<h1 id="#title_14" >15、Fiery 0.5.6.2-beta 发布，PHP 性能跟踪监控系统</h1>

[https://www.oschina.net/news/92629/fiery-0-5-6-2-beta](https://www.oschina.net/news/92629/fiery-0-5-6-2-beta)
<p>更新内容：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;SQL去重改为语法分析方式 - 提高统计精准性</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Logpusher 内存使用阻塞队列方式设计结构，降低内存使用及浪费</p><p>目前还在beta阶段，欢迎试用。</p><p>Fiery 是一款为PHP提供服务的性能跟踪监控系统，可以方便的查看线上调用关系，响应性能，回放请求过程，参数，系统异常、性能统计，部署简单方便，所有服务都集成在一个jar包内，除Java Runtime无其他依赖，开箱即用。</p>
---------------
<h1 id="#title_15" >16、LuaScriptCore v2.1.0 发布，移动端 Lua 桥接框架</h1>

[https://www.oschina.net/news/92628/luascriptcore-2-1-0](https://www.oschina.net/news/92628/luascriptcore-2-1-0)
<p>LuaScriptCore旨在能够在多种平台上方便地使用Lua。其提供了与各种平台的功能交互，让开发者无须关心Lua与各个平台之间是实现交互的细节，只需要根据自己的业务需求，使用LuaScriptCore提供的方法，轻松简单地实现各种功能。其能做到：</p><ol class=" list-paddingleft-2"><li><p>从平台原生层代码调用Lua中的方法和变量，控制Lua的业务逻辑</p></li><li><p>从Lua中调用原生层提供的方法，让一些Lua无法处理或者耗时的处理交由原生方法实现</p></li><li><p>从原生层中直接扩展Lua的功能</p></li><li><p>从原生层定义的类直接映射到Lua中使用，让Lua更方便地实现面向对象的编程</p></li></ol><p>本次更新内容如下：</p><ol class=" list-paddingleft-2"><li><p>LuaValue增加Class类型</p></li><li><p>完善异常捕获检测，让问题定位更加准确</p></li><li><p>修复继承Object对象的Lua类型操作异常问题。</p></li><li><p>优化查找属性和获取属性值业务逻辑</p></li><li><p>优化GC回收处理</p></li><li><p>异常捕获优化，修正原生方法执行异常后无lua异常报告问题。</p></li><li><p>增加TmpValue，用于解决Table类型原生转换后再回传lua产生的变化问题。</p></li><li><p>修复父类属性在子类重写后无法正常调用问题。</p></li><li><p>修复Unity下多个LuaContext相互影响问题。</p></li><li><p>修复对象创建时在init方法中调用self相关的属性和方法导致栈溢出问题。</p></li><li><p>修复Lua中直接调用subclass派生类型无法进行扩展类型属性定义问题。</p></li></ol>
---------------
<h1 id="#title_16" >17、协作翻译 | 一些文本编辑器的实用技巧和经验分享</h1>

[https://www.oschina.net/translate/helping-your-text-editor-help-you](https://www.oschina.net/translate/helping-your-text-editor-help-you)
<p>这不是一篇关于你应该使用哪个文本编辑器的博客，这里分享了一些这些天编辑器的示例。</p>
---------------
<h1 id="#title_17" >18、JiaoZiVideoPlayer v6.2.5 发布，视频播放控件</h1>

[https://www.oschina.net/news/92643/jiaozivideoplayer-6-2-5](https://www.oschina.net/news/92643/jiaozivideoplayer-6-2-5)
<p>JiaoZiVideoPlayer&nbsp;v6.2.5&nbsp;已发布，更新内容：</p><ol class=" list-paddingleft-2"><li><p>修复列表大量数据时由于取得电量错误的崩溃</p></li><li><p>release MediaPlayer 时清空消息队列</p></li><li><p>demo 中添加视频单独静音的例子</p></li><li><p>其他 bug 修复</p></li></ol><p>JiaoZiVideoPlayer 是一款 Android 视频播放控件，特性如下：</p><ol class=" list-paddingleft-2"><li><p>可以完全自定义UI和任何功能</p></li><li><p>一行代码切换播放引擎，支持的视频格式和协议取决于播放引擎，</p></li></ul>
---------------
<h1 id="#title_18" >19、码云推荐 | PHP 接入实现百度文字和图像识别 BaiduOcr</h1>

[https://gitee.com/paultest/BaiduOcr](https://gitee.com/paultest/BaiduOcr)
<p>使用PHP接入 百度文字识别 以及 图像识别。</p>
---------------
<h1 id="#title_19" >20、每日一博 | 五年架构师讲述 RESTful 架构风格</h1>

[https://my.oschina.net/u/3770281/blog/1609893](https://my.oschina.net/u/3770281/blog/1609893)
<p>如果开发者对RESTful 架构风格不甚了解，则开发出的所谓RESTful API总会貌合神离，不够规范。</p>
---------------
<h1 id="#title_20" >21、Mozilla 承诺：Firefox 58 将带来意想不到的速度</h1>

[https://www.oschina.net/news/92623/firefox-58-out-next-week-says-mozilla](https://www.oschina.net/news/92623/firefox-58-out-next-week-says-mozilla)
<p>认为火狐 Quantum 速度很快？Mozilla，Firefox 58的新编译器和流媒体编译功能会让页面加载速度更快。</p><p><img alt="" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0121/022307_sXNd_3703517.jpg" src="https://static.oschina.net/uploads/space/2018/0121/022307_sXNd_3703517.jpg"/></p><p>Mozilla承诺，即将推出的 Firefox 58 将进一步提高加载速度，Firefox 57中引入的新引擎（称为Quantum），该引擎可更好地利用多核CPU。</p><p>编译 WebAssembly 代码时，Firefox 58 的编译速度会更快，这要归功于“流式编译（streaming compilation，它允许并行编译和下载代码 ）” 和更快的双层（two-tiered ）编译器。</p><p>Mozilla开发团队的工程师 Lin Clark 说到，流式编译和双层编译器让 Firefox 58 编译代码的速度比网络传递数据包的速度快，从而消除了页面加载速度慢的瓶颈。过去，网络性能受到网络的限制，尤其是CPU和主线，Firefox 58 减轻了主线程的负担，更好地利用了CPU的时间。</p><p>Firefox 58 中的流编译器会让浏览器加载WebAssembly文件的速度比同等大小的JavaScript文件更快。</p><p>同时，Firefox 58 的双层编译器会在编译非优化代码时优化代码的编译时间。</p><p>Firefox 58目前处于测试阶段，计划于1月23日发布，而Mozilla希望最新的版本会吸引更多的前用户。</p>
---------------
<h1 id="#title_21" >22、全球 100 强技术公司排行榜：微软打败谷歌成为第一巨头</h1>

[https://www.oschina.net/news/92622/microsoft-beats-apple-to-become-the-world-s-number-1](https://www.oschina.net/news/92622/microsoft-beats-apple-to-become-the-world-s-number-1)
<p>微软在汤森路透（Thomson Reuters）本周发布的“</p>
---------------
<h1 id="#title_22" >23、22 岁的 Google 工程师：发现了震惊科技界的 CPU 漏洞</h1>

[https://www.oschina.net/news/92621/google-enginer-find-cpu-bug](https://www.oschina.net/news/92621/google-enginer-find-cpu-bug)
<p>中央处理器（CPU）的推测执行</p>
---------------
<h1 id="#title_23" >24、OSChina 周日乱弹 ——程序员的好日子什么时候才到头？</h1>

[https://my.oschina.net/xxiaobian/blog/1610207](https://my.oschina.net/xxiaobian/blog/1610207)
<p>程序员的四种境界：初级程序员(菜鸟)、高级程序员(熟练工)、系统程序员(高手)、软件大师(大师)，你能修炼到几级？</p>
---------------
<h1 id="#title_24" >25、根据 Dice 和 Linux 基金会调查：来看看国外开源人员现状</h1>

[https://www.oschina.net/news/92619/open-source-professionals-are-more-in-demand-than-ever](https://www.oschina.net/news/92619/open-source-professionals-are-more-in-demand-than-ever)
<p>你想做一名技术人员吗？那么你应该提高你的开源技术。据世界领先的求职网站&nbsp;Dice&nbsp;和&nbsp;Linux 基金会称，公司正在努力提高生产效率来缩短产品的上市时间，所以对专业的开源人士的需求很大。</p><p><img alt="" height="300" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0118/173757_35MV_3703517.jpg" src="https://static.oschina.net/uploads/space/2018/0118/173757_35MV_3703517.jpg" width="472"/></p><p>根据这两个组织在得出报告：“89%的 HR 表示很难找到合适的开源技术人才，58%的表示在未来6个月需要招聘更多的开源专业人才。”</p><p>和去年的报告一样，重点关注的是开源软件的各个方面，但是四年前关注的是Linux专业人才。</p><ul class=" list-paddingleft-2"><li><p>67% 的管理人员表示，在未来六个月招聘开源专业人士的比例会超过其他业务领域。</p></li><li><p>60％ 的公司正在寻找全职开源技术雇员，而去年为53％。</p></li><li><p>将近一半（47％）的公司将开通员工开源认证。</p></li><li><p>在职位需求上：开发人员（73％），DevOps 工程师（60％）和系统管理员（53％）。技术需求上：开源云计算（47％），应用程序开发（44％），大数据（43％）以及 DevOps（42％）。</p></li></ul><p>任何事情都发生都是有原因的，开源已成为主流的软件开发方法。互联网巨头微软也逐渐成为一个开源公司。就在最近几天，微软与红帽达成战略合作，发布了开源的 .NET Core 2.0 编程框架，并将在 Linux 和 Windows 上发布 SQL Server 2017。</p><p>雇主表示技能位于第一，OpenStack&nbsp;和&nbsp;Cloud Foundry&nbsp;等云技术是最受欢迎的。Cloud Foundry&nbsp;正在迅速普及。70% 的雇主正在寻找有云经验的员工。</p><p>网络技术位居第二，67％ 的雇主正在寻找具有 JavaScript 和相关技能的员工，比去年上升了5％。虽然招聘 Linux 专家的职位下降了6%，但是对 Linux 人才的需求依然强劲。</p><p>影响雇佣决策最重要的技术是云（62％），应用平台（56％）和大数据（53％）。具体而言，60%的雇主最期待的开源技能是云/虚拟化。其次是应用程序开发（59％）和DevOps（57％）。</p><p>Dice 总公司 DHI 集团总裁兼首席执行官 Michael Durney 在一份声明中表示：“随着开源技术的日益提高，越来越多的公司在全球范围内利用这些技术，对拥有开源经验的专业人才的需求只会增加。&quot;</p><p>Linux 基金会执行董事吉姆·泽姆林（Jim Zemlin）对此表示赞同：“开放源码是软件开发领域的主导力量，对于那些寻找具有发展前景职业的人来说，机会比比皆是。&nbsp;“</p><p>对于个人，如果想做一名技术人员，找到一份高薪工作，那么今天就拿起Linux和开源技术。</p>
---------------
<h1 id="#title_25" >26、谷歌 CEO 表示：比编程能力更重要的是持续学习</h1>

[https://www.oschina.net/news/92618/more-important-than-programming-is-continuous-learning](https://www.oschina.net/news/92618/more-important-than-programming-is-continuous-learning)
<p>本周，谷歌CEO桑达尔·皮查伊（Sundar Pichai）在一篇发表在NBCNews上的文章中提到，<strong>尽管编程在如今的学校教育和职业培训中很受欢迎，不过在自动化普及的未来，不是所有的科技行业岗位都要求很硬的编程能力。</strong></p><p>皮查伊说：“一提到怎样提升生产力并在科技行业中寻求工作机会等问题，人们首先想到的一个词就是“编程”。在过去十年中，几乎所有有关技术技能的项目都聚焦于计算机科学，特别是面向青年学生的项目。但是在科技行业中过于重视编程也给另一些技能创造了潜在机会。”</p><p><img alt="" data-cke-saved-src="https://static.oschina.net/uploads/space/2018/0120/231324_tCmD_3703517.jpg" src="https://static.oschina.net/uploads/space/2018/0120/231324_tCmD_3703517.jpg"/></p><p>他表示：“技术不密集的、中等层次的职业岗位在迅速被数字化和自动化，在你的职业生涯中需保持敏锐的态度，不断接受培训。在过去，人们接受教育，同时也学习职业技能，那么就能找到不错的工作。而现在不一样了，随着科技的快速发展，新的职业领域在不断出现和变化。”</p><p>这位谷歌CEO强调说：“我们需要聚焦于普及轻量的、持续不断的教育。这很重要，能确保每一个人都能在未来的工作环境中找到机会。”</p><p>对此他举例说道，公司的管理者中也需要有掌握计算机技能的人，他们现在都在线安排日程、做预算、和记账。对普通员工也应该开设相关计算机技能的培训课程，当然，他们不需要获得一个正式的计算机学位。</p><p>这些计算机相关技能比起编程来说更容易学，也能进行规模化培训。对此，皮查伊引用的相关数据表示，在美国，只需“中等计算机技能”的职业数量从2002年的40%增长到了2016年的48%。</p><p>皮查伊表示，在科技行业中另一个不需要编程能力但需要接受少许技术教育的职业类别是IT技术支持。他说：“IT技术支持很明显是个机会。就像如果想成为汽车修理工就有一条必走的技能培训的路一样，我们需要有一条通往拥有超过15万工作机会的IT技术支持的路。IT技术支持主要的工作内容是维护机器和支撑技术服务的软件。然而，目前还缺少IT技术支持相关岗位的培训。”</p><p>以上说到的这些都不需要强大的编程能力，重要的是多开设培训课程，使现有劳动力为未来的工作做准备。皮查伊强调说：“将注意力从编程和学位转移到这些轻量的、无处不在的教育。将轻量、灵活的课程和技能培训带给每一个人。”</p><p>来自：</p>
---------------
<h1 id="#title_26" >27、Lerna v2.8.0 发布，多包存储库管理工具</h1>

[https://www.oschina.net/news/92640/lerna-2-8-0](https://www.oschina.net/news/92640/lerna-2-8-0)
<p>将大型代码库拆分为独立的独立版本包对于代码共享非常有用。 然而，在许多存储库中进行更改是麻烦和难以跟踪的事情。为了解决这些（和许多其他）问题，一些项目将它们的代码库组织成多包存储库。 像 Babel、React、Angular、Ember、Meteor、Jest 等等。</p><p>Lerna&nbsp;是一个优化使用 git 和 npm 管理多包存储库的工作流工具，用于管理具有多个包的 JavaScript 项目。</p><p><strong>Lerna v2.8.0&nbsp;更新内容：</strong></p><p>改进</p><ul class=" list-paddingleft-2"><li><p></p></li></ul>
---------------
<h1 id="#title_27" >28、文章： 开发者需要知道的有关软件架构的五件事</h1>
Simon Brown
[http://www.infoq.com/cn/articles/architecture-five-things?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/architecture-five-things?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/architecture-five-things/zh/headerimage/GettyImages-628133388-1515148866077.jpg"/><p>了解软件架构基础比以往任何时候都要来得重要，因为我们现在构建的系统越来越趋于分布式化，而且开发团队也越来越分布式化。为了解开这些迷思，开发者需要了解五个与软件架构有关的事实。</p> <i>By Simon Brown</i> <i> Translated by 薛命灯</i>
---------------
<h1 id="#title_28" >29、文章： 阿里盒马领域驱动设计实践</h1>
张群辉
[http://www.infoq.com/cn/articles/alibaba-freshhema-ddd-practice?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/alibaba-freshhema-ddd-practice?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/alibaba-freshhema-ddd-practice/zh/smallimage/tb-1516533903541.jpg"/><p>设计是把双刃剑，没有最好的，也没有更好的，而是条条大路到杭州。同时不设计和过度设计都是有问题的，恰到好处的设计才是我们追求的极致。</p> <i>By 张群辉</i>
---------------
<h1 id="#title_29" >30、文章： P2P如何将视频直播带宽降低75%？</h1>
袁荣喜
[http://www.infoq.com/cn/articles/p2p-decrease-live-bandwidth?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/p2p-decrease-live-bandwidth?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/articles/p2p-decrease-live-bandwidth/zh/smallimage/GettyImages-509049212 copy-1516536413752.jpg"/><p>基于 P2P 技术的整个分发架构在一个 10W+ 直播平台上进行了 9 个月的测试和调优，初步达成了设计目标。那整个系统是怎么设计的？使用了哪些技术来达成目标？接下来我来重点分享一下架构设计和技术细节。</p> <i>By 袁荣喜</i>
---------------
<h1 id="#title_30" >31、视频演讲： FreeWheel OLAP实践</h1>
姜冰
[http://www.infoq.com/cn/presentations/the-practice-of-freewheel-olap?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/the-practice-of-freewheel-olap?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/presentations/the-practice-of-freewheel-olap/zh/mediumimage/jiangbin270-1516273693914.jpg"/><p>FreeWheel是一家主要服务于北美和欧洲客户的视频广告技术公司，为大型电视媒体和优质内容供应商提供企业级的视频广告解决方案，每天完成近10亿次视频广告投放，积累了大量的视频观看和广告投放数据。

在公司的大数据平台之上，我们构建以Presto为核心的OLAP，满足实时查询的要求。随着业务对于Presto的增长，效率、延迟以及数据管理成为制约Presto OLAP应用的重要问题。</p> <i>By 姜冰</i>
---------------
<h1 id="#title_31" >32、视频演讲： 全链路稳定性背后的数字化支撑：阿里巴巴鹰眼技术解密</h1>
周小帆
[http://www.infoq.com/cn/presentations/alibaba-hawk-eye-technology-decryption?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/alibaba-hawk-eye-technology-decryption?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/presentations/alibaba-hawk-eye-technology-decryption/zh/mediumimage/zhouxiaofan270-1514032244702.jpg"/><p>阿里的电商业务系统基于微服务框架构建，其变更频繁，业务变化快，系统依赖关系错综复杂。基于全链路的稳定性保障、容量规划、性能优化、压测演练、业务故障排查定位等运维手段也逐步系统化、常态化。
从2010年的第一代“鹰眼”系统诞生以来，阿里的全链路监控系统不断升级、演进与创新，为 DevOps 和 SRE 在阿里的实际落地提供了行之有效的数字化支撑。
最新一代的阿里全链路监控系统鹰眼3.0，同时将基础设施层、分布式应用层、业务逻辑层与客户端层进行了全链路跟踪；技术层面，鹰眼3.0日均处理万亿级别的分布式调用链数据，针对海量实时监控的痛点，对底层的流计算、多维时序指标与事件存储体系等进行了大量优化，同时引入了时序检测、根因分析、业务链路特征等技术，将问题发现与定位由被动转为主动。
</p> <i>By 周小帆</i>
---------------
<h1 id="#title_32" >33、视频演讲： 深度学习在视频重复检测中的实践</h1>
伏圣国
[http://www.infoq.com/cn/presentations/practice-of-deep-learning-in-video-repetition-detection?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/practice-of-deep-learning-in-video-repetition-detection?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/presentations/practice-of-deep-learning-in-video-repetition-detection/zh/mediumimage/fushengguo270-1516166967454.jpg"/><p>随着手机与基础网络设施的普及和高速发展，用户消费内容逐渐由文字变为多媒体，深入分析微博平台上丰富的图片及视频势在必行，而深度学习在其中发挥着非常关键的作用。本次分享主要介绍深度学习在视频重复检测中的应用，主要内容涉及三个部分：
（1）分别介绍基于深度模型的图像、音频的重复检测算法以及面临的问题；
（2）针对图像和音频算法面临的问题，怎样对两者进行有效地结合；
（3）围绕视频量大且耗时的问题，怎样高效且高质量地检索候选重复视频，用于后续的精确对比。</p> <i>By 伏圣国</i>
---------------
<h1 id="#title_33" >34、视频演讲： AI技术落地工业，打造无忧工业理想未来</h1>
刘宗长
[http://www.infoq.com/cn/presentations/ai-technology-industry-landing?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/ai-technology-industry-landing?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="https://res.infoq.com/presentations/ai-technology-industry-landing/zh/mediumimage/liuzongchang270-1516167787889.jpg"/><p>AI技术的浪潮向工业领域袭来，有人说它会颠覆人与技术之间的关系，重构工业秩序，也有人认为它能扭转生产力曲线，是中国变道超车进入制造强国之列的关键技术之一。无论技术怎样变换，其本质是如何为行业带来真正的价值。天泽智云将通过具体的实践案例，解读AI应用于具体工业场景的技术框架和设计理念。</p> <i>By 刘宗长</i>
---------------