## 文章索引
1、 <a href="#1译前端是-🤘-而-javascript-是-👑" >【译】前端是 🤘 而 JavaScript 是 👑</a><br/>
2、 <a href="#2译巧用-css-变量实现自动前缀|-lea-verou" >【译】巧用 CSS 变量实现自动前缀！| Lea Verou</a><br/>
3、 <a href="#3译chrome-的-v8-javascript-引擎得到调整-|-infoworld" >【译】Chrome 的 V8 JavaScript 引擎得到调整 | InfoWorld</a><br/>
4、 <a href="#4值得订阅的-12-份优质前端期刊" >值得订阅的 12 份优质前端期刊</a><br/>
5、 <a href="#5别人家的面试题不用加减乘除求整数的7倍" >别人家的面试题：不用加减乘除，求整数的7倍</a><br/>
6、 <a href="#6译是什么使一名好程序员变得伟大" >【译】是什么使一名好程序员变得伟大</a><br/>
7、 <a href="#7译少写代码少填坑-medium" >【译】少写代码少填坑 – Medium</a><br/>
8、 <a href="#8译一家初创公司的-cto-应当做什么" >【译】一家初创公司的 CTO 应当做什么？</a><br/>
9、 <a href="#9译hover-已死永垂不朽" >【译】Hover 已死，永垂不朽</a><br/>
10、 <a href="#10用树莓派驱动德飞莱16x16点阵屏显示汉字" >用树莓派驱动德飞莱16x16点阵屏显示汉字</a><br/><h1 id="#title_0" >1、【译】前端是 🤘 而 JavaScript 是 👑</h1>

[https://www.h5jun.com/post/front-end-is-and-javascript-is.html](https://www.h5jun.com/post/front-end-is-and-javascript-is.html)
<blockquote>
<p>原文：</p>
</blockquote>
<p>前端将要统治世界，让 JavaScript 君临天下，而码农们则在争论着我们的技术究竟变得有多复杂。</p>
<p>现代前端技术饱受争议，但是我们只顾争吵，似乎忘记了我们所得到的回报。我们，web 王国的劳动人民、web 设计师、前 Wordpress 工程师和吟唱代码的诗人，将要统治数字世界，能够建造各种神迹。谁会想到这一切都是我们的老朋友 JavaScript 所带来的。这个当年的 👶 语言只能用来做些许有趣的 DOM 操作。谁又想到它竟然有这样的超能力？</p>
<!--more-->
<p>我听说了一些观点比如<strong>“现代前端被过度工程化了”</strong>,<strong>“别用大炮打蚊子”</strong>以及<strong>“webpack有必要搞那么复杂吗？”</strong>😾但我不赞同。我认为最近前端工具和库的发展简直是非凡的成就。web 的未来将由一个充满狂热者和理想主义者的社区创建，他们创造伟大的工具给所有 web 开发者免费使用。这其中许多人的背后的支持者是一些大公司，它们默默地做了许多繁重的工作，投资开源项目和工具。除了前端，还有哪个行业如此开放？</p>
<h4 id="-">追求卓越天然不易</h4>
<p>所以我们在这里开发应用，这些应用曾经得完全依靠 C#、Java 或者 .NET 来实现，用很慢的服务器渲染界面，或者更糟，开发灰暗而令人压抑的桌面应用 🔫。在那段岁月中，如果某些 UX 设计师被雇佣，只要能够改变应用中文本的颜色，他们就感到谢天谢地。这段苦日子已经过去了，如今我们可以创造我们最想要的 ❤️。但是，我们也得付出努力。</p>
<p>谁说前端是容易的？创建一个应用让它<strong>超级快</strong>，<strong>使用起来有趣</strong>以及<strong>可维护</strong>可不是一件琐碎的事。实际上这是一门艺术。不过幸运地是，伟大的新工具每周都会涌现。它们都是来拯救我们并赋予我们创造这些神奇应用更强大的能力的🎉。</p>
<h4 id="-">拥抱学习</h4>
<p>拥抱现代前端技术，我们要让学习成为我们工作的一部分。我不是说你需要学习你从前端资讯中了解到的一切新东西，但是，如果你兴趣十足并且心态开放，多学学是一个好的开始。</p>
<p>在众多批评现代前端的声音中我感受到了一些阻力。一些反对学习和理解新知识的阻力。这种态度会让你退缩，让你跟不上时代。前端已经驶上了发展的快车道🚀，它不会停下来等待那些质疑者。跳上快车可能令人内心恐惧，但最好不要犹豫。前方风景优美，别让恐惧阻止你前进的脚步。</p>
<p>说到这，我们也需要承认我们不是全能的专家。性能优化、常规部署、安全性和应用架构，这些不需要也不可能全部精通。当我们往前深入下去，我们将选择更专业的方向。这也是为什么几年前很火的“全栈工程师”逐渐淡出人们的视野。</p>
<h4 id="-">为什么学习很有必要</h4>
<p>我们用户对使用诸如 Uber 和 AirBnb 一类的在线服务的期望与日俱增。所以只满足于“能做到”已经远远不够了，我们需要创造用户真正喜欢的在线服务。要实现这个目标我们需要知识，以及许多工具，让你不需要一切都从头开始做。我们需要框架、库、模块，打包工具，辅助工具，包管理工具等等。要记得，一切工具的目的都是为了解决一个特定的问题。必须要确定哪个问题是痛点，以及你是否确实需要解决它😉。</p>
<p>如果你开发的网站比较大，我非常确定引入现代前端工具可以让你的网站和你的生活都变得更美好。它们能让你的网站更健壮、易于维护以及，最后但同样重要的，让你的网站有更漂亮的 UI 和更丰富的交互体验。</p>
<h4 id="javascript-">JavaScript 的未来</h4>
<p>所以，我们才刚刚开始。JavaScript 赢得了编程语言的战争并将要统治世界🌎。JavaScript 的简易性和几乎是通用的标准让它变得极为强大。它在客户端和服务器上都能够快速渲染的能力是令人瞩目的。JavaScript 已经打入原生应用开发，我们周围的世界已经被 JavaScript 连接起来，JavaScript 将会出现在各种地方。</p>
<p>有了这些能力，我们可以创造奇迹。可以开发无人机来救援被困的人，开发新一代支付解决方案，开发人造机器人以及其他各种不可思议的产品。有一件事情是明确的，现在是成为前端工程师的好时代！🦄</p>
<blockquote>
<p>英文原文：</p>
</blockquote>
---------------
<h1 id="#title_1" >2、【译】巧用 CSS 变量实现自动前缀！| Lea Verou</h1>

[https://www.h5jun.com/post/autoprefixing-with-css-variables-lea-verou.html](https://www.h5jun.com/post/autoprefixing-with-css-variables-lea-verou.html)
<blockquote>
<p>原文：</p>
</blockquote>
<p>最近，当我在制作 需要同时使用无前缀的版本和一个<code>-webkit-</code>前缀的版本，我的这个方法可以适用于这种情况，不管这个 CSS 属性是什么，有多少种前缀，只要它不论什么前缀的值都是同样的就可以。</p>
<!--more-->
<p>第一步是在所有元素上定义一个 <code>--clip-path</code> 属性，值是 initial。这样阻止这个属性在每一次使用的时候被继承，而由于 <code>*</code> 没有特异性，任何使用了 <code>--clip-path</code> 的声明都能被覆盖。然后你定义所有不同版本的属性名，值为 <code>var(--clip-path)</code>：</p>
<pre><code class="hljs lang-css">* {
  <span class="hljs-attribute">--clip-path</span>: initial;
  <span class="hljs-attribute">-webkit-clip-path</span>: <span class="hljs-built_in">var</span>(--clip-path);
  <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">var</span>(--clip-path);
}
</code></pre><p>这样，在我们需要使用 clip-path 的地方，我们都用 --clip-path 替代，它可以正常工作：</p>
<pre><code class="hljs lang-css"><span class="hljs-selector-tag">header</span> {
  <span class="hljs-attribute">--clip-path</span>: <span class="hljs-built_in">polygon</span>(0% 0%, 100% 0%, 100% calc(100% - 2.5em), <span class="hljs-number">0%</span> <span class="hljs-number">100%</span>);
}
</code></pre><p>甚至连 <code>!important</code> 都可以正常工作，因为。除了上面这个问题，我没发现其它的缺点了（除了显然必须使用与标准属性有些不同的属性之外），但是如果你有发现别的坑，请在评论里面留言让我知道！</p>
<p>我想，CSS 变量的巧妙用法还有许多有待发掘。我想要知道这个技巧是否能改进一下让它支持自定义 css 属性全写，比如将 <code>box-shadow</code> 分开成 <code>--box-shadow-x</code> 和 <code>--box-shadow-y</code> 等等，但是目前我还没想到好办法。你有好办法吗？😉</p>
<blockquote>
<p>英文原文：</p>
</blockquote>
---------------
<h1 id="#title_2" >3、【译】Chrome 的 V8 JavaScript 引擎得到调整 | InfoWorld</h1>

[https://www.h5jun.com/post/chrome-039-s-v8-javascript-engine-gets-a-tuneup-infoworld.html](https://www.h5jun.com/post/chrome-039-s-v8-javascript-engine-gets-a-tuneup-infoworld.html)
<blockquote>
<p>原文：</p>
</blockquote>
<p><img src="https://p0.ssl.qhimg.com/t018c5a19fb3e56e4ba.jpg" alt=""></p>
<h2 id="v8-">V8 团队和俄罗斯开发者为浏览器引擎提供了内存优化和代码改进</h2>
<!--more-->
<p>V8 是 Google 的 Chrome 浏览器的 JavaScript 引擎，由 V8 团队和俄罗斯科学院提供性能改进和代码优化。</p>
<p>V8 团队发布了 5.4 版本，它是引擎的一个新的分支。“V8 5.4 提供了内存占用和启动速度方面的一些关键改进”，开发团队在发布公告里说。“这些改进主要有助于加速初始化脚本执行，并减少在 Chrome 中的页面加载时间”。</p>
<p>V8 5.4 的发布为 512MB 及以下 RAM 的设备调整了垃圾回收机制，减少约百分之40的堆内存（on-heap memory）峰值消耗，具体减少内存的效果取决于被展示的网站内容。同时，JavaScript 解析器中的内存管理被简化了，以避免不必要的内存分配，这减少了多达 20% 的堆外内存（off-heap memory）的消耗。</p>
<p>解析器的运行时性能优化也得到了改进。“这个优化，连同其他 JavaScript 内置优化，以及使用全局内联缓存访问 JavaScript 对象属性，共同显著地提升了启动性能”，开发团队如是说。</p>
<p>V 5.4 分支将作为 beta 版发布，直到几周以后它将随同 Chrome 5.4 稳定版浏览器一起正式发布。</p>
<p>同时，俄罗斯科学院系统规划研究所的开发人员从 V8 中 fork 出了一个。</p>
<p>上个月末，。它改进了脚本执行，减少了内存开销，同时还有提升网页加载速度的潜力。</p>
<blockquote>
<p>英文原文：</p>
</blockquote>
---------------
<h1 id="#title_3" >4、值得订阅的 12 份优质前端期刊</h1>

[https://www.h5jun.com/post/the-12-best-weekly.html](https://www.h5jun.com/post/the-12-best-weekly.html)
<p>作为前端从业人员，能够及时接收行业最新最前沿技术资讯，是个人成长的一项必备技能。大家都知道前端发展迅速，每周都有新东西出现。那么行业里面究竟有哪些值得关注和订阅的前端资讯类期刊呢？我将多年整理和收集的 12 份优质期刊分享给大家（排名不分先后）</p>
<!--more-->
<h2 id="-">英文期刊</h2>
<h3 id="frontend-focus">Frontend Focus</h3>
<p><img src="https://p4.ssl.qhimg.com/d/inn/a3896375/frontend-focus.jpg" alt=""></p>
<p>老牌前端周刊，以介绍 HTML/CSS 技术的文章为主。目前第 263 期，原来叫做 html5 weekly，现在改为 FrontEnd Focus。有不少适合新手的入门文章，内容难度适中，比较适合于前端新人。一般是每周四更新。</p>
<h3 id="javascript-weekly">JavaScript Weekly</h3>
<p><img src="https://p2.ssl.qhimg.com/d/inn/a3896375/javascript-weekly.jpg" alt=""></p>
<p>老牌 JavaScript 期刊，目前已经第 307 期。最近介绍 Node.js 和 ES6 的内容比较多。技术难度适中，比较适合于新人以及有一定经验的 JavaScript 工程师。除了资讯和技术文章它也会推荐一些适合新人入门的教程和视频（视频在某网站，要翻墙，你懂的），一般是每周五更新。</p>
<h3 id="css-weekly">CSS Weekly</h3>
<p><img src="https://p1.ssl.qhimg.com/d/inn/a3896375/css-weekly.jpg" alt=""></p>
<p>老牌 CSS 期刊，目前已经 236 期。主要介绍 CSS 基础、动画、响应式设计、CSS 预处理等。也介绍一些不错的工具和开源项目。比较适合于前端新人。一般是每周三更新。</p>
<h3 id="node-weekly">Node Weekly</h3>
<p><img src="https://p5.ssl.qhimg.com/d/inn/a3896375/node-weekly.jpg" alt=""></p>
<p>Node.js 开始流行的时候出现的周刊，目前到第 161 期，内容是以介绍 Node 和 ES6 为主。它会定期介绍和推荐一些新的开源库、框架和工具，其中不乏有优秀的值得关注的项目。一般是每周五更新。</p>
<h3 id="mobile-web-weekly">Mobile Web Weekly</h3>
<p><img src="https://p5.ssl.qhimg.com/d/inn/a3896375/mobileweb-weekly.jpg" alt=""></p>
<p>从周刊名字就可以知道，这个周刊主要是介绍移动端的 web 技术。它目前更新到第 131 期。介绍响应式设计、web 游戏开发、移动端交互设计以及各种移动 web 开发相关的库、工具和技术。部分内容比较深入，适合主要工作以移动开发为主的前端工程师订阅。一般是每周三更新。</p>
<h3 id="full-web-weekly">Full Web Weekly</h3>
<p><img src="https://p0.ssl.qhimg.com/d/inn/a3896375/fullweb-weekly.jpg" alt=""></p>
<p>以 web 全栈技术为主的期刊，内容涉及面较广，不仅仅有 JavaScript，还有 Python、PHP 等服务端技术，比较适合有一定经验的前端工程师，尤其是希望跨界的高级前端工程师扩展学习。一般是每周三更新。</p>
<h3 id="web-design-weekly">Web Design Weekly</h3>
<p><img src="https://p1.ssl.qhimg.com/d/inn/a3896375/web-design-weekly.jpg" alt=""></p>
<p>名字听起来像是介绍 UI 设计的周刊，但是其实介绍前端开发的内容更多。不愧是 web design，周刊界面比较好看而且是响应式的。一般是每周三更新。</p>
<h2 id="-">中文期刊</h2>
<h3 id="-">奇舞周刊</h3>
<p><img src="https://p2.ssl.qhimg.com/d/inn/a3896375/75-weekly.jpg" alt=""></p>
<p>老牌的国内前端期刊了，由 360 前端，奇舞团小伙伴们每周整理。目前已经到第 182 期。内容包括行业内最新的中文前端技术原创和翻译文章以及最新资讯。内容全面，其中也不乏好的入门教程，比较适合新人。除了邮件订阅之外，有微信公众号，可以在微信里订阅。一般是每周五更新。</p>
<h3 id="fex-">FEX 技术周刊</h3>
<p><img src="https://p3.ssl.qhimg.com/d/inn/a3896375/fex-weekly.jpg" alt=""></p>
<p>由百度 FEX 整理的技术周刊，内容很全，从行业会议到各类优秀中英文精品文章，还有最新资讯和互联网产品和其他相关内容。是我目前所知道的国内唯一同时有中英文文章推荐的周刊，每期内容非常非常多，比前面各个周刊都全。有微信公众号，可以在微信里订阅。一般是每周一更新。</p>
<h3 id="-">众成翻译每周精选</h3>
<p><img src="https://p0.ssl.qhimg.com/d/inn/a3896375/zcfy-weekly.jpg" alt=""></p>
<p>由众成翻译提供的每周译文精选。众成翻译是国内最大的前端技术文章翻译平台。上面介绍的几个英文期刊的文章中很大一部分都会及时在众成翻译上翻译成中文。因此如果英文阅读比较吃力的同学，可以直接阅读众成翻译每周精选上的中文译文版。这也是国内唯一的推荐专业译文的前端周刊。一般是每周日更新。</p>
<h3 id="-">湾区日报</h3>
<p><img src="https://p1.ssl.qhimg.com/d/inn/a3896375/wanqu-daily.jpg" alt=""></p>
<p>这是旧金山湾区的技术日报，作者是旧金山一家创业公司的软件工程师。它严格来说不属于前端范畴，但它每天推荐高质量的互联网创业与技术资讯，非常适合前端和其他互联网从业人员阅读。可以通过邮箱订阅，一般是每日更新。</p>
<h2 id="-">日文期刊</h2>
<h3 id="frontend-weekly">Frontend Weekly</h3>
<p><img src="https://p5.ssl.qhimg.com/d/inn/a3896375/frontend-weekly.jpg" alt=""></p>
<p>这是日本前端从业者整理的周刊，推荐的文章主要还是英文的，文章跨域度比较大，几乎包含所有前端相关的领域，其中不乏有优质文章。不过内容上和前面几个英文周刊有一定的重复。一般是每周三更新。</p>
<p>以上就是我常阅读的技术期刊，如果大家有自己订阅的其他不错的期刊，欢迎在评论区讨论~</p>
---------------
<h1 id="#title_4" >5、别人家的面试题：不用加减乘除，求整数的7倍</h1>

[https://www.h5jun.com/post/multiply7.html](https://www.h5jun.com/post/multiply7.html)
<p>这是今天早晨来公司无意中听到的题目，据说是某部门 C++ 工程师的面试题。作为爱思考的小前端，听到了也不免会想如果是自己遇到这样一道面试题该怎样做。</p>
<p><img src="https://p4.ssl.qhimg.com/t01b96bacb705f8727e.jpg" alt=""></p>
<!--more-->
<p>这道题目的第一感，相信很多同学都和我想得一样 —— 和二进制有关。但是，我们知道二进制的操作最方便计算的是 2 次幂的倍数，比如 8 倍，不考虑大数溢出的话，就只要将该整数左移三位就可以了，对应的代码就是：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">let</span> multiply8 = (num) =&gt; num &lt;&lt; <span class="hljs-number">3</span>;

multiply8(<span class="hljs-number">7</span>); <span class="hljs-comment">//56</span>
</code></pre>
<p>你看，8 倍很容易实现，但是 7 倍该怎么做呢？理论上可以先将该数扩大 8 倍，然后再减去自己。可是，题目又限制了不允许使用加减乘除，那么怎么办呢？有兴趣的同学可以思考 5 分钟，再往下看。</p>
<h2 id="-">不用加号的二进制整数加减法</h2>
<p>这道题的关键在于不能使用运算符号，那么一个直接的思路就是能不能不用加减乘除实现整数的加减法呢？其实不难，复习一下大学课本里面计算机组成原理，应该能想起来如何实现基本的加减乘除法。这里，我们其实只需要实现一个基本的加法：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>a + b</th>
<th>进位</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>无</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>无</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>无</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>有</td>
</tr>
</tbody>
</table>
<p>从上面的表可以看出一种实现简单的<strong>多位</strong>二进制整数加法的算法如下：</p>
<h3 id="m-n-m-n-">m 和 n 是两个二进制整数，求 m + n：</h3>
<ol>
<li>用<strong>与运算</strong>求 m 和 n 共同为 “1” 的位： m&#39; = m &amp; n</li>
<li>用<strong>异或运算</strong>求 m 和 n 其中一个为 “1” 的位： n&#39; = m ^ n</li>
<li>如果 m&#39; 不为 0，那么将 m&#39; 左移一位（进位），记 m = m&#39; &lt;&lt; 1，记 n = n&#39;，跳回到步骤 1</li>
<li>如果 m&#39; 为 0，那么 n&#39; 就是我们要求的结果。</li>
</ol>
<p>把上面的算法翻译成 JavaScript ：</p>
<pre><code class="hljs lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bitAdd</span>(<span class="hljs-params">m, n</span>)</span>{
    <span class="hljs-keyword">while</span>(m){
        [m, n] = [(m &amp; n) &lt;&lt; <span class="hljs-number">1</span>, m ^ n];
    }
    <span class="hljs-keyword">return</span> n;
}

bitAdd(<span class="hljs-number">45</span>, <span class="hljs-number">55</span>); <span class="hljs-comment">//100</span>
</code></pre>
<p>以上，我们就得到了一个自己实现的整数加法，于是我们可以：</p>
<pre><code class="hljs lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply7</span>(<span class="hljs-params">num</span>)</span>{
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++){
        sum = bitAdd(sum, num);
    }
    <span class="hljs-keyword">return</span> sum;
}

multiply7(<span class="hljs-number">7</span>); <span class="hljs-comment">//49</span>
</code></pre>
<p>这样我们得到了想要的结果，不过如果要改进的话，我们其实可以不需要用循环加法来实现整数乘法，回到前面讨论过的，我们可以先将 num 乘以 8，然后再减去 num，或者说 bitAdd(-num)。</p>
<p>所以我们可以这么做：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">let</span> multiply7 = (num) =&gt; bitAdd(num &lt;&lt; <span class="hljs-number">3</span>, -num);

multiply7(<span class="hljs-number">7</span>); <span class="hljs-comment">//49</span>
</code></pre>
<p>有同学说，负数符号也是减号“-”，能不能不使用？当然可以，因为我们可以利用“补码”：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">let</span> multiply7 = (num) =&gt; bitAdd(num &lt;&lt; <span class="hljs-number">3</span>, bitAdd(~num, <span class="hljs-number">1</span>));

multiply7(<span class="hljs-number">7</span>); <span class="hljs-comment">//49</span>
</code></pre>
<p>好了，到这里，似乎我们得到了一个很完美的解法，不过呢，从数学上，我们还是可以“吹毛求疵”一下：因为在前面的算法里面，我们循环迭代 m 和 n，那么我们的循环什么时候能停下来呢？或者说，这个算法的时间复杂度是多少？</p>
<p>要解决这个问题也很简单，我们简单思考一下，就可以得出，每次迭代的时候，m 末尾连续的 0 一定会至少增加 1 位（因为 &amp; 操作不可能减少 m 末尾的 0，而 1 位左移操作至少会增加 1 个末尾的 0）。当 m 末尾连续的 0 的数量超过 n 的二进制位数之后， m &amp; n 就是 0，此时循环就会结束。因此，这个算法的最坏情况下，循环次数是 log(n)，时间复杂度小于等于 O(log(n))。</p>
<h2 id="-">其他解法？</h2>
<p>上面我们用自己实现的加法解决了这个算法面试题，那么有没有别的什么做法呢？当然也是有的，比如我们可以直接用循环和位操作实现二进制乘法，或者不实现加法，改为实现二进制减法，甚至利用 JavaScript 语言特性用一些投机取巧的方法，比如下面的做法就不违反题意：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">let</span> multiply7 = (num) =&gt; 
    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>([<span class="hljs-string">"return "</span>,num,<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">42</span>),<span class="hljs-string">"7"</span>].join(<span class="hljs-string">""</span>))();

multiply7(<span class="hljs-number">7</span>); <span class="hljs-comment">//49</span>
</code></pre>
<p>总之，有各种解法可以玩，多思考总是好的。作为前端，对这样的题目也可以讨论许多方法，有许多思路可以学习。所以，写 C++ 的同学，也要加油，至少别被这样的面试题给难倒。好歹是写 C++ 的，别在算法上输给我大前端 😄</p>
---------------
<h1 id="#title_5" >6、【译】是什么使一名好程序员变得伟大</h1>

[https://www.h5jun.com/post/what-makes-a-good-developer-great.html](https://www.h5jun.com/post/what-makes-a-good-developer-great.html)
<blockquote>
<p>原文：</p>
<p>别满足于足够好 —— 来自一位技术总监的忠告。</p>
</blockquote>
<p><img src="https://p1.ssl.qhimg.com/t0137965c123c0ae941.jpg" alt=""></p>
<!--more-->
<p>作为一名年轻的程序员，我渴望在我的职业生涯中成长，我想要知道为了成为一名高级程序员，我们的目标要怎么设定。我询问过我的经理和导师，并惊讶地发现，要成为高级程序员，不仅仅是依靠学习和掌握技术（当然你需要不断学习，要保持技术领先）。除了技术之外，成为优秀程序员需要关注团队合作、沟通和注意细节。几乎没有一点行业经验的新手也可以根据技术判断出什么样的程序员是优秀的，但是需要一点技术之外的东西才能让你从优秀程序员中脱颖而出，成为伟大的程序员。</p>
<p><strong>好程序员测试她的代码来确保它能正常工作。</strong></p>
<p><strong>伟大的程序员测试她的代码来确保它不会不工作。</strong></p>
<p>这可不是文字游戏 —— 正向和逆向测试之间有明显区别，而两者在软件工程中都是必不可少的。每个人在写好代码之后都测试他们的代码来确保它能按照他们的预期工作。但是，这只是第一步。通过不同的用例或用户行为，充分思考出错的潜在风险并防御性地编程来避免一些问题，能有助于让你的应用有很长的“保质期”。</p>
<p><strong>好程序员积极协助设置代码约定。</strong></p>
<p><strong>伟大的程序员遵守代码约定，即使它们与她自己的习惯不符。</strong></p>
<p>遵守代码约定是一件大事。这么做的目的是让开发团队的思想统一，而约定对实现理想的思想统一是至关重要的。它需要成熟的心态和卓越的承诺，为了团队更好，妥协你做事情的方式，从而产生更多的凝聚力和一致的工作。团队中的最强的人会理解团队合作和达成共识的重要性。</p>
<p><strong>好程序员写简洁的代码。</strong></p>
<p><strong>伟大的程序员写简洁的代码，最后再整理一遍并为它撰写文档。</strong></p>
<p>如果你满足于让代码“足够好”，那么它实际上还不够好。要以高标准来对待你的工作，要记住当下一次你再阅读你写的代码的时候，由于时过境迁，你不会马上有相同的理解，而其他人检阅代码时，他们可能需要你的指点，你得告诉他们为什么你当时用这个方法实现。考虑以最好的方式来组织你的代码，并在你写了与它有关的其他组件之后再重新审视它。这些都是关于精益求精，重构使它优雅而高效。同时，为你的代码写文档。这非常重要。你团队的标准和代码约定应当强制使用代码注释。要把你的想法准确传达给使用你的代码的其他程序员，通过一个 readme 文件甚至一个 wiki 来整理清晰的文档，告诉使用者这些代码能做什么以及如何使用（给出例子）。</p>
<p><strong>好程序员能独立解决问题。</strong></p>
<p><strong>伟大的程序员认识到她所在团队的专业知识的价值并在需要的时候充分挖掘团队的力量。</strong></p>
<p>虽然对于工程师来说独立工作的能力是重要的，但依赖团队也是很好理解的，每个人都需要在项目的某个点上接受指导，甚至需要一点点帮助。一名初级工程师可能在日常任务上需要更多手把手的指导，而一个更高级的工程师可能需要对岗位要求的澄清或者在性能优化方面的指导。需要指导没什么不好意思的。最重要的一点是别害怕问问题，而一旦你的问题解决了，你可以继续前进直到遇到下一个障碍。成为一个独行侠没什么好处，那样你会为迟迟无法成功而感到沮丧，而那些驱动整个项目的人也会为项目迟迟没有进展而感到沮丧。一个成熟的、有自信的程序员知道她的能力和弱点，不害怕向团队成员求助，必要时借助团队力量而不是试图成为个人英雄。</p>
<p><strong>好程序员学习效率工具并将它们有效地用于简化她的工作流。</strong></p>
<p><strong>伟大的程序员自己定制工作来提高效率并改进她的工作环境和工作流。</strong></p>
<p>用你在项目中使用到的一切技术，花点时间改进流程。它也能对前面提到的一些点有帮助，比如写一个 linter（代码提示工具）来检查你的代码，看是否严谨和符合约定，或者写测试工具来自动化测试你的代码流程。</p>
<p><strong>好程序员评审她团队成员的代码来保证质量。</strong></p>
<p><strong>伟大的程序员在代码评审中给出详细的，合理的，建设性的评论来帮助与她一起共事的程序员，让他们在知识和专业领域上有所成长。</strong></p>
<p>理解沟通的重要性并以高标准严格要求。优雅地推动你的同事不断进步，为他们的职业生涯清除障碍，这将会让你成为一名好的领导者。这让我们回归合作的本质 —— 为了更大的群体利益，而且这也是在知识上的投资，能帮助你的团队成功。</p>
<p>这些都是随着时间的推移而建立的技能和习惯。我坚信“我们从一开始就要相信自己能行”（凡事都得有开始），但是我也相信“我们没法掩盖沮丧”。成功没有捷径。真正的技巧和专业知识是经过长时间的开发实践积累的。都说做一件事需要花费 10000 小时，才能成为行家。谁都可以选择掌握深度或者掌握广度，广度提升我们对大方向的理解而深度则提升我们的专业能力 —— 其实，这两者都不可或缺。热爱你的职业生涯旅途并学会欣赏你自己成长的过程。但不管你是一名有十年经验的老手还是才入行一个月的菜鸟，不要满足于足够好。在你的团队成为伟大的程序员并领导其他人，照顾好他们。</p>
<blockquote>
<p>英文原文：</p>
</blockquote>
---------------
<h1 id="#title_6" >7、【译】少写代码少填坑 – Medium</h1>

[https://www.h5jun.com/post/writing-less-damn-code-medium.html](https://www.h5jun.com/post/writing-less-damn-code-medium.html)
<blockquote>
<p>原文：</p>
</blockquote>
<p>我不是这个世界上最有才的程序员。是的，我知道这是真的。所以我尝试尽可能少写代码。我写得越少，破坏越少，调整和维护的工作量也就越少。</p>
<p>我也很懒，所以觉得一切过得去就行了。</p>
<!--more-->
<p>然而，事实证明让 Web 变得高效的唯一行之有效的方法也只是少写代码。精简代码？压缩代码？缓存？好吧，听起来好高级。从源头上竭尽全力拒绝增加代码或者引入别人写的代码？<strong>现在你说到点子上了。</strong>解决一个问题又会带来另一堆别的问题，你的任务可能让你无比蛋疼。</p>
<p>而这还没完。不同于为了可见的性能收益的优化目标 —— 如果确实有可见的优化点，你还是需要多写一些代码，不过你得想好了 —— 少写代码可以让你的 Web 应用使用成本降低。我接收的数据内容不在乎你用小块还是大块数据发送，反正它们拼起来之后都一样（意思是性能优化不明显的话没必要过度合并请求 —— 译者注）。</p>
<p>我最喜欢的关于少写代码更好的观点是：你应该只完成你真正需要的东西 —— 即你的用户真正需要的东西。在按钮上加一道光？别说道光，加康熙也不干。为了加社交按钮引入一堆第三方代码，同时破坏掉你的页面设计？将它们一脚踹开。用 JavaScript 定制用户的鼠标右键来显示一个自定义的模态对话菜单？代表月亮消灭它们。</p>
<p>这不仅仅是关于你引入代码来破坏 UX 设计的问题，你自己写的代码也必须要尽量减少。这里我提供一些观点会有帮助。我曾经写过一些不用写的代码，用在无障碍和响应式设计方面。结果却让我明白一个道理，灵活的、无障碍的 Web 正需要我们尽可能少去人为控制。只有不写的代码才永远都不需要重写。</p>
<h4 id="wai-aria">WAI-ARIA</h4>
<p>首先，WAI-ARIA(Web Accessibility Initiative - Accessible Rich Internet Applications) 不等于 Web 无障碍。它只是一个工具，在需要的时候通过某些辅助技术来提高兼容性，比如支持读屏软件。因此， 是如果你不是必须要用的时候<em>不要</em>使用 WAI-ARIA。</p>
<p>为了德玛西亚！别这样写：<span style="color:grey">（<em>原文这里是 LOL，no:，LOL 应该是 Laugh Out Loud，不过我故意翻译成那个的 😂 —— 译者注</em>）</span></p>
<pre><code class="hljs lang-applescript">&lt;<span class="hljs-keyword">div</span> role=<span class="hljs-string">"heading"</span> aria-level=<span class="hljs-string">"2"</span>&gt;Subheading&lt;/<span class="hljs-keyword">div</span>&gt;
</code></pre><p>应该这样写:</p>
<pre><code class="hljs lang-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Subheading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
</code></pre><p>使用原生元素的好处是你通常也不需要为你的元素行为添加脚本。看下面的 checkbox 实现，这么写不仅代码很冗长，而且还需要依赖一段 JavaScript 来控制状态变化从而  出本来就是浏览器标准化的 name 属性和 HTTP GET 的基本行为。明显这么写需要更多代码，而且不那么健壮。搞笑吧？</p>
<pre><code class="hljs lang-applescript">&lt;<span class="hljs-keyword">div</span> role=<span class="hljs-string">"checkbox"</span> aria-checked=<span class="hljs-string">"false"</span> tabindex=<span class="hljs-string">"0"</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"checkbox1"</span> aria-labelledby=<span class="hljs-string">"label-for-checkbox1"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt; &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"label"</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">"label-for-checkbox1"</span>&gt;My checkbox label&lt;/<span class="hljs-keyword">div</span>&gt;
</code></pre><p>上面那么写是为了要考虑样式？没关系，如果你真的需要自定义样式，。</p>
<pre><code class="hljs lang-stata">&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"checkbox"</span> id=<span class="hljs-string">"checkbox"</span> name=<span class="hljs-string">"checkbox1"</span>&gt; &lt;<span class="hljs-keyword">label</span> <span class="hljs-keyword">for</span>=<span class="hljs-string">"checkbox1"</span>&gt;My checkbox <span class="hljs-keyword">label</span>&lt;/<span class="hljs-keyword">label</span>&gt;
</code></pre><h4 id="grids">Grids</h4>
<p>你记得曾经享受使用/阅读一个超过三栏布局的网页吗？我不觉得那是一种享受。太多的内容堆在一起，干扰了我的注意力。“我想知道那些看起来像是导航栏的东西它真的是我想要的导航栏吗？” 这样的网站套路太深，我要做的任务被打断了，于是我离开了这个网站。</p>
<p>有时候我们确实想要内容堆在一起。比如搜索结果或者其他什么。但是为什么要引入一整个笨重的栅格框架模板只为了实现这个功能？Flexbox 用三两个声明块就能做到。</p>
<pre><code class="hljs lang-css"><span class="hljs-selector-class">.grid</span> { 
  <span class="hljs-attribute">display</span>: flex; 
  <span class="hljs-attribute">flex-flow</span>: row wrap; 
} 

<span class="hljs-selector-class">.grid</span> &gt; * { 
  <span class="hljs-attribute">flex-basis</span>: <span class="hljs-number">10em</span>; 
  <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>; 
}
</code></pre><p>现在一切都“扭曲”为大约 10em 宽。一行有多少列取决于 viewport 可以放下大约多少个 10em 宽的单元格。搞定，继续。</p>
<p>然后，当我们来到这里，下面这个是什么鬼：</p>
<pre><code class="hljs lang-hsp"><span class="hljs-keyword">width</span>: <span class="hljs-number">57.98363527356473782736464546373337373737</span>%<span class="hljs-comment">;</span>
</code></pre><p>你知道精确的测量是根据一个神秘的比例计算的吗？一个令人敬畏的神奇比例？不，我不觉得，也不感兴趣。<strong>我只想要让播放动作片的按钮足够大以便我能找到它。</strong></p>
<h4 id="margins">Margins</h4>
<p>。使用通用选择器让元素共享 margin 定义。只在需要改变的地方重写它，不需要更复杂。</p>
<pre><code class="hljs lang-dos">body * + * { 
  margin-top: <span class="hljs-number">1</span>.<span class="hljs-number">5</span><span class="hljs-comment">rem; </span>
}
</code></pre><p>不，通用选择器不会破坏你页面的性能，别被砖家坑了。</p>
<h4 id="views">Views</h4>
<p>你不需要一整个 Angular 或者 Meteor 或者别的什么来分离一个简单的网页到“视图”。视图只是分别控制你所能看见的网页部分和你看不见的部分，CSS 也可以做到：</p>
<pre><code class="hljs lang-css"><span class="hljs-selector-class">.view</span> { 
  <span class="hljs-attribute">display</span>: none; 
} 

<span class="hljs-selector-class">.view</span><span class="hljs-selector-pseudo">:target</span> { 
  <span class="hljs-attribute">display</span>: block; 
}
</code></pre><p>“但是单页应用需要在它们加载视图的时候执行代码！”我知道你要说这个。这个用 onhashchange 事件就好了。不需要其他库，你只需要使用标准的，可收藏到书签的链接方式就可以了。这很棒。。</p>
<h3 id="font-sizes">Font sizes</h3>
<p>调整字体大小真的可以让你的 @media 块膨胀。这也是为什么你需要小心照顾好你的 CSS。其实用一行代码可以解决：</p>
<pre><code class="hljs lang-hsp"><span class="hljs-keyword">font</span>-size: calc(<span class="hljs-number">1</span>em + <span class="hljs-number">1</span>vw)<span class="hljs-comment">;</span>
</code></pre><p>嗯，这样就行了。你甚至有了字体的最小大小，所以在手机上字体也不会变得太小。多亏了  教会了我这个。</p>
<h3 id="-10k-apart-https-a-k-apart-com-"></h3>
<p>如我所说的，我不是最好的程序员。我只是了解一些技巧。但是要明白每多一点就可能会破坏很多。这是  的前提 —— 找出仅通过 10k 或更少代码能做到什么。这个比赛获胜的奖金很高，作为裁判，我期待着能发现各种令人惊叹想法及实现。我也希望我自己能想出好点子。如果你来参加这个比赛，你将要做什么？</p>
<blockquote>
<p>英文原文：</p>
</blockquote>
---------------
<h1 id="#title_7" >8、【译】一家初创公司的 CTO 应当做什么？</h1>

[https://www.h5jun.com/post/what-does-a-startup-cto-actually-do.html](https://www.h5jun.com/post/what-does-a-startup-cto-actually-do.html)
<blockquote>
<p>原文：</p>
</blockquote>
<p>你的首席技术官（CTO）整天都在做什么？很多时候，在一般人眼里的 CTO 形象等同于“那个拿着高薪坐在角落里，对‘技术’进行深层次思考的家伙” 或者 “那个在最后一刻突然一时兴起，跳起来重新安排我的项目的家伙”。我已经努力不让人产生这种印象，但这不容易做到。我们缺乏一个对 CTO 的一致而明确的角色定位。</p>
<!--more-->
<p>当我问起我那些曾在大公司任 CTO 的导师们如何看待这一角色，他们通常会谈起 CTO 应该成为公司技术平台的对外形象，对开发者、客户（尤其是技术型产品）、员工来说，CTO 是布道者。毫无疑问，技术布道是一项非常重要的工作，我总是被要求做这件事。然而，我不认为大多数初创公司真正需要某人来做全职的布道者。</p>
<p>所以 CTO 意味着什么，除了只是 “不负责直接管理任何人的技术合伙人？”。</p>
<p>我一直认为我不会管理任何人。我打心底认为成为一个经理一点也不好玩，谁会真的想对别人的行为负责？我的意思是，公司大了，什么人都有（不好管理）！所以我被 CTO 的职位吸引，而不愿意成为分管工程师的 VP。我认为公司会招一个专业的家伙来专门负责管理和安排日常事务，而我只要将精力集中于确保我们的技术确实很牛逼。然而，一路走过来，一些奇怪的事情发生了。我发现软件的研发过程和软件的架构变得越来越难以分离。如果你尝试设计一个架构来最大化软件的灵活度，在没法保证所有的开发者都采用 TDD 时，事情是推动不下去的。如果在推动决策时，一部分人采用“预先筹划<sup>1</sup>” 而另一部分人使用 “5 个为什么<sup>2</sup>”，事情也会一团糟。如果每次产品发布都需要手工部署怎么办？一些做法可以改进软件的性能，但要牺牲可读性、部署能力或可扩展性，你会去做吗？这对我来说像是技术问题，但是当你深入分析问题的本质时，你会发现它们实际上是人的问题。而人的问题真的没有办法以一个旁观者的立场来解决。</p>
<p>所以我学习了如何管理他人。还好，我并没有太不擅长管理，而且我发现原来它可以带来很大的回报。但尽管我在 CTO/VP 的混合角色上经历了很长时间，我仍然有这一挥之不去的困惑，即究竟 CTO 应该做些什么？</p>
<p>以下是我的观点。我认为 CTO 的主要工作是确保公司的技术策略服务于它的商业策略。如果这听起来太简单或者太泛泛了，思考一秒钟，是否有你所知道的公司做的正好相反，是否你有听说过有所谓的“砖家”把技术的繁文缛节当做经营理念来坑老板和投资人？这正是我们要极力避免的。</p>
<p>我会将它分解为五个特定的技能：</p>
<ul>
<li><p>平台选择与技术方案设计 —— 如果你的商业策略是创建一个低消耗、快速迭代高效率的创新产品，你最好使用基础工具让它变得简单而不是变得复杂。大规模专用数据库？我不认为在这里适用。公司的技术支持团队是否能够深入他们开发的工具，在有问题时解决和修复？如果不能，谁能主张并坚持切换到免费和开源的软件？当产品想法变得越来越天马行空，谁能检查并确保整个计划可行？新上线项目对整个平台造成影响应当追究谁的责任？</p>
</li>
<li><p>把控全局（包括一些关键细节）—— CTO 是整个项目中能够了解整套技术方案能做什么不能做什么的人。这意味着了解什么可行，什么不可行，当前架构能支持什么，做不到什么，以及构建一个新功能在先有架构下要多长时间。这可不是简单画一个架构图就完事的。能够同时看清整体和细节是所有我有幸与之共事的真正优秀的技术人员的共同特质。</p>
</li>
<li><p>提供选择 —— 另一个好 CTO 的标志是他们从不说 “这是不可能的” 或 “我们永远别这样做”。相反，他们找到可选方案并且能够就这些方案与其他人沟通。如果 CEO 想要完全改变一个产品来服务于新客户群体，需要找一个能扛起新业务需求的人，并制定出每种可能的方法所需耗费的成本。一些技术人员有一种倾向，只是“为你决定”并给你一个“最好的”选择，但这是危险的。如果一方宣称他知道所有的答案，你们之间就不是一个可信的对话。</p>
</li>
<li><p>80/20原则 —— 这是我最喜欢的一部分工作。有时候，你在一个会议中，有人会提出一个新功能。在他们脑海里，他们灵光一现，加这个功能，加那个功能，最好再加一堆。在我看来，他们在增加成本（实现这个部分要一个月，那个部门要两个月，……）。有时候，我会给他们泼一桶冷水。而有时候，一旦我理解了他们要添加的功能的目的是什么，我可以找到一个获得 80% 好处而只要消耗 20% 成本的折衷方案。我一直很惊讶我经常会听到“什么？原来这个功能实现起来很难？！我还以为只要加一两行代码就搞定了呢！”</p>
</li>
<li><p>培养技术 leader —— 我将这个职责定义为培养工程师成为“技术经理”并授权他们指导更多项目的技术方向。一个人的能力是有限的。为了做到这个，我也必须要清楚公司哪方面的技术方向是真正重要的，而哪些只是我们为了达到目的的过度方案。为了让多人以同样的标准工作，我们必须在我们的定义中增加一些保障。比如我们必须要采用 PHP，还是我们能加入一些用别的语言写的工具？是否需要保证所有的网页代码都用面向过程风格？如果有人想要把他们的模块用面向对象风格来写行不行？通过授权和培训，我们培养了一些 leader，他们能够分担 CTO 的工作。而通过一起工作，我们创建了一个团队，通过合作，让。</p>
</li>
</ul>
<p>我想加最后一个想法，尽管我知道它是有争议的，介于 CTO 和技术 VP 的职责之间。我不知道我被同时履行两个角色的职责影响了多久，但我认为它是重要的，足以让我决定冒着被喷的风险将它列出来。</p>
<ul>
<li>拥有开发方法论 —— 在传统的产品开发配置中，技术 VP 或者类似的管理角色全权负责确保工程师写的代码足够规范，接口有质量保证，并有节奏地发版。但是我想在一个精益的初创团队，开发方法论比只是单纯管理要重要多了。例如，一个团队是否使用 TDD 或者，对架构会有很大的影响。最起码，我认为 CTO 和技术主管对缺陷和问题要能够找到和分析根本原因。否则他们如何能够找到什么是他们的盲点并确保团队和架构能得到及时调整？这项工作要求具备全局视野。</li>
</ul>
<p>你的 CTO 可能是一个好的架构师、布道师、接口设计师或调试 bug 的天才。这些都是非常好的能力，我很好奇你是否在你们的 CTO 身上见过这些能力。我承认我的经验是有限的，所以我在收集案例。你是否与一个很棒的 CTO 共事？是什么使得他们让你觉得很棒？一个新任命的CTO，你能从他身上学到什么？</p>
<ul>
<li>注<sup>1</sup>        </li>
<li>注<sup>2</sup> </li>
</ul>
<blockquote>
<p>英文原文：</p>
</blockquote>
---------------
<h1 id="#title_8" >9、【译】Hover 已死，永垂不朽</h1>

[https://www.h5jun.com/post/hover-is-dead-long-live-hover.html](https://www.h5jun.com/post/hover-is-dead-long-live-hover.html)
<blockquote>
<p>原文：</p>
</blockquote>
<p><img src="https://p.ssl.qhimg.com/t01708f6c417d5bbf4a.png" alt=""></p>
<p>在 2013 年 2 月，web 在使用方式上经历了一个巨大的变化，而直到 3 年之后，这一变化依然不被工程师和设计师们意识到。在那个月，两台笔记本电脑问世：Chromebook Pixel 和 Microsoft Surface。它们是第一批带有触摸屏支持笔记本电脑模式的主流设备。从那以后，平板和笔记本电脑 2 合 1 成为主流，而因为它们，鼠标 hover 很大程度上变得不可靠了。</p>
<!--more-->
<hr>
<p>两年半之前，我针对一款桌面 web 产品做用户研究，这款产品允许读者在线评论一篇新闻稿（感觉上类似于多说、畅言之类的评论系统 —— 译者注）。我们已经观察到大量不同年龄段、不同类型的用户会通过将鼠标悬停在每一行来逐行阅读，甚至高亮他们已经阅读过的文本。于是，我们决定让我们的产品一开始不可见，直到用户将他的鼠标悬停在任意段落上才出现。这么做没问题……直到有人使用了原版的 Surface Pro。</p>
<p><img src="https://p.ssl.qhimg.com/t01cf32b42b63dc17c0.png" alt=""></p>
<p>Surface Pro 配备了一个触摸板和一个触摸屏。用户可以像在平板或手机上那样在 Surface Pro 上阅读文章，用他的手指沿着屏幕滚动。</p>
<p><strong> 这意味着他不能使用我们的产品。他在页面上看不到我们的产品。即使他知道怎样看到我们的产品，没有一个操作能让他将 UI 显示出来。</strong></p>
<p>这难住了我们的以  苹果为中心的团队，最后我们放弃了支持 Surface Pro，把它作为一个个例抛弃。那段时间，原版的 Surface 在市场上卖得不好，我们希望这个问题随着 Surface 下市而消失。</p>
<p>然而并没有……</p>
<hr>
<h3 id="-hover">如何在美好的新世界使用 hover</h3>
<p>从那以后，许多提供触屏的 Windows 和 Chromebook 便携式电脑问世。每一个主流个人电脑厂商现在都会销售 2 合 1 便携式电脑设备（包括  苹果公司）。互联网数据中心（IDC）认为，到 2020 年，2 合 1 设备将占有所有平板设备销量的 30%。</p>
<p>当设计师和工程师们着手建立桌面 web 应用时，他们需要考虑这些设备的能力。典型的 UI 指南会将以前大而笨重的按钮换成看起来小一些的，增加屏幕信息展现密度，并增加访问 hover 的能力。以上这些都是在支持触屏的世界里需要被重新考虑的。</p>
<h4 id="-">+ 应当做</h4>
<p>Hover 行为仍然非常重要。鼠标和触控板还会存在。使用 hover 行为可以给用户关于是否可点击或结果可能是什么的重要提示。</p>
<ul>
<li>使用 hover 给使用鼠标的用户关于可点击元素的提示。</li>
<li>使用 hover 来快速触发行为，但是要确保 hover 不是必须的。</li>
<li>提供一个首选方式，让用户用手指触摸能够与 hover 做同样的事情。</li>
</ul>
<p><img src="https://p.ssl.qhimg.com/t012d99a1498fae9ce5.png" alt=""></p>
<p>在默认情况下，我们的产品主体界面能够用 hover 调出，但你也可以点击选项卡来将它的完整界面调出。</p>
<h4 id="-">× 别做</h4>
<p>别将 hover 作为首选行为来触发任何不可或缺的操作。记住，永👏远👏不👏要👏！</p>
<hr>
<p>下一次当你收到用户的反馈邮件，说他们用便携式平板笔记本不能使用你的产品的主体功能时，请重视他们的反馈。也许这会让你一劳永逸地杀死 hover。</p>
<blockquote>
<p>英文原文：</p>
</blockquote>
---------------
<h1 id="#title_9" >10、用树莓派驱动德飞莱16x16点阵屏显示汉字</h1>

[https://www.h5jun.com/post/pi-led16x16.html](https://www.h5jun.com/post/pi-led16x16.html)
<p>这周尝试用树莓派驱动了  点阵屏。之所以选用这一款是因为它是 16 X 16 点阵（实际上是 4 块 8 X 8 LED 拼起来的，只不过已经集成好了）。LY-LED16x16B V2.1 本身是用于单片机的，官方提供了 51 单片机和 Arduino 下的测试程序。不过，我们有强大的树莓派，既然单片机能驱动，树莓派应该也不是问题。</p>
<p><img src="https://dn-h5jun.qbox.me/matrix/FXGVviUOrFDo8DLglzttTh6I.jpg" style="max-width:640px"></p>
<!--more-->
<style>
    article img{
        max-width: 640px;
        width: 100%;
    }
</style>

<p><em>德飞莱 LY-LED16x16B V2.1 led 点阵屏用在单片机开发板</em></p>
<p><img src="https://dn-h5jun.qbox.me/matrix/p61UcFIeNAQ0iwJCEoiZnDBR.jpg" alt="LY-LED16x16B V2.1"></p>
<p><em>德飞莱 LY-LED16x16B V2.1 led 点阵屏连接树莓派</em></p>
<p><img src="https://dn-h5jun.qbox.me/matrix/kBChYxpXyCHytEs-u37AnVtB.jpg" alt="LY-LED16x16B V2.1"></p>
<p><em>点亮效果（文字旁边的虚影不是因为显示问题，而是因为手机拍照时文字是移动的）</em></p>
<p>那么，树莓派驱动这样一块集成 16 X 16 LED 点阵屏具体该怎么做呢？</p>
<h2 id="-">点阵屏显示的原理</h2>
<p><img src="https://dn-h5jun.qbox.me/matrix/cfSsEo7uLq0gMPSx1FwIEXcc.jpg" alt=""></p>
<p>上面这张图是 LY-LED16x16B 的电路原理图，很久没接触数字电路的小伙伴看了是不是觉得头晕？其实一看到这张图，我也觉得晕，不过没有关系……</p>
<p>我们先来搞清楚点阵屏显示的基本原理：</p>
<h3 id="-8x8-led-">简单 8x8 LED 点阵屏</h3>
<p>基础的 8x8 点阵屏其实是这货——</p>
<p><img src="https://dn-h5jun.qbox.me/matrix/No8mI9ZpnWE4b6Ck75drLHmD.jpg" alt=""></p>
<p>它的原理比较简单：</p>
<p><img src="https://dn-h5jun.qbox.me/matrix/vRaHH6H-K_qbuODWxNxjAfLE.jpg" alt=""></p>
<p>上面这张图应该容易理解，它其实就是发光二极管排列成矩阵，利用二极管的单向导通特性，分别用 8 行、8 列一共 16 个引脚来控制。平时 R1 ~ R8 为低电平，C1 ~ C8 为高电平，此时二极管不导通。当要点亮第 i 行，第 j 列时，让 Ri 输出高电平，Cj 输出低电平即可。这样用 16 个引脚就可以来控制，显示的时候，每次只能控制一行，否则就会点亮我们不希望点亮的点。比如要想点亮 R2C2、R3C3 两个点，就要将 R2、R3 置为高电平，C2、C3 置为低电平，但如果同时操作的话，R2C3 和 R3C2 这两个点也会被点亮，所以只能先将 R2 置为高电平，C2 置为低电平，点亮 R2C2，然后将 R2、C2 恢复，再将 R3 置为高电平，C3 置为低电平。实际上这种方式也就是所谓的逐行扫描。</p>
<h3 id="-8x8-16x16">从 8x8 到 16x16</h3>
<p>我们看到驱动普通的 8x8 点阵屏就要 16 个引脚，而 8x8 点阵屏对于显示汉字来说是远远不够的，那么为了显示汉字，我们就要将 4 个 8x8 点阵屏连接起来组成一个 16 x 16 点阵屏，但是这样的话，可想而知需要的引脚数量就更多了，用树莓派驱动如此多数量引脚的设备显然不现实。</p>
<p>然而，我们并不需要直接连接 4 个点阵屏，我们可以使用带有集成电路的 16x16 点阵屏，比如上面那一款。</p>
<h3 id="ly-led16x16b-v2-1">LY-LED16x16B V2.1</h3>
<p>我们看一下 LY-LED16x16B 与普通点阵屏的区别。</p>
<p><img src="https://dn-h5jun.qbox.me/matrix/BtvMYo3RPxveWcL7Y9IeYnqQ.jpg" alt=""></p>
<p>可以看到 LY-LED16x16B 由四块 8x8 点阵屏和一些控制器组成。它一共有 22 个引脚，但只有右侧 11 个引脚是输入引脚，左侧的 11 个 是输出引脚，用于多片级联。11 个输入引脚中除去最下方两个引脚是 VCC 和 GND 外，一共有 9 个控制引脚，从上到下分别是：R1、D、C、B、A、LATCH、SCK、G1、EN/OE。</p>
<p>这些引脚又分为几类：</p>
<ul>
<li><p>R1/G1，点亮 LED 灯的输入引脚。有的屏是红绿双色的，R1 是点亮红色，G1 是点亮绿色，因为我们是单色屏，所以 G1 引脚是不用的。注意这个 LED 点阵屏是共阳的，所以要点亮的话，应当输入低电平。</p>
</li>
<li><p>D/C/B/A，行选信号，这是四位行选信号，表示点亮哪一行，例如要点亮第三行，需要向 B 引脚输入高电平，其他三个引脚输入低电平（行号从0开始，第一行是0000，第二行是0001，所以第三行是0010）。</p>
</li>
<li><p>LATCH/SCK，SCK 是时钟信号，LATCH 是锁存器。注意到前面 R1/G1 输入只有一位，行选可以选行，那么我们怎么确定要点亮当前行的哪一列呢？这就需要用时钟和锁存器了。实际上如果学过数字电路的同学会比较容易理解。在这里我们用到触发器串行输入的概念，利用时钟脉冲信号触发寄存器存储当前值，一共 16 位寄存器能够存储 16 个值（最近的 16 个脉冲时，R1/G1 的逻辑值），当输入完成后，通过 LATCH 锁存器将寄存器的值保存，然后点亮 LED 灯输出。</p>
</li>
<li><p>EN/OE 使能端，输出高电平时将关闭屏幕，这是因为实际显示时，逐行扫描的频率很高，锁存器输出和切换行几乎同时进行，因此切换时要将屏幕关掉，不然可能会将上一行的信号部分带到下一行，让字产生虚影（正常显示点旁边会有微弱点亮的LED）。</p>
</li>
</ul>
<p>所以其实要显示内容的程序逻辑并不复杂，伪代码如下：</p>
<pre><code class="hljs lang-hsp"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){
    <span class="hljs-keyword">for</span>(var i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 16; i++){//行选</span>
        LATCH = <span class="hljs-number">0</span><span class="hljs-comment">; //打开锁存，接收输入信号</span>
        <span class="hljs-keyword">for</span>(var j = <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; 16; j++){</span>
            R1 = 当前位输出
            <span class="hljs-comment">//给一个脉冲，记录到寄存器</span>
            SCK = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
            SCK = <span class="hljs-number">1</span><span class="hljs-comment">;         </span>
        }
        <span class="hljs-comment">//一行写完了准备写入当前行</span>
        OE = <span class="hljs-number">1</span><span class="hljs-comment">; //通过使能端关闭屏幕，避免虚影</span>
        ROW = i<span class="hljs-comment">;    //通过四位行选信号选择当前行</span>
        LATCH = <span class="hljs-number">1</span><span class="hljs-comment">; //锁存并输出</span>
        OE = <span class="hljs-number">0</span><span class="hljs-comment">; //打开使能，将数据显示在屏幕上</span>
    }
}
</code></pre><p>可以看到，使用了 LATCH/SCK 之后操作并不复杂，却大大减少了需要的引脚数量，这就是集成 LED16x16 的作用。接下来该连线了。</p>
<h3 id="-">设计电路</h3>
<p>电路原理图如下：</p>
<p><img src="https://dn-h5jun.qbox.me/pi-led-7.svg" alt=""></p>
<p>由于 LY-LED16x16B 需要 5V 供电，虽然也可以用树莓派供电，但为了以后扩展，最好还是接外部电源，因此 +5V 和 GND 不接树莓派。</p>
<ul>
<li>R1 接 P36</li>
<li>LATCH/SCK 分别接 P38、P40</li>
<li>OE 使能端接 P32</li>
<li>行选信号接 P29、P31、P33、P35</li>
</ul>
<p>这样，理论上电路就可以工作了，但是有一个地方需要注意，由于输入端 R1 在树莓派不输出的时候悬空，SCK 频率又很高，容易产生噪点，影响显示效果，因此，最好在 R1 端加一个下拉电阻来稳定输入（阻值不能太大也不能太小，在 1k 左右即可），避免噪点产生：</p>
<p><img src="https://dn-h5jun.qbox.me/pi-led-8.svg" alt=""></p>
<p>至此，电路设计就完成了。</p>
<h2 id="-">设计程序</h2>
<p>现在要开始设计驱动程序了。根据我们前面分析的原理，我们需要逐行输出。在这里我们可以使用一个16位二进制数来表示一行，也可以使用一个数组来表示。为了 JS 方便操作，我们不妨直接用数组来表示：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">var</span> pixels = [
    [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0.</span>.....,<span class="hljs-number">0</span>], <span class="hljs-comment">//第 1 行</span>
    [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1.</span>.....,<span class="hljs-number">1</span>], <span class="hljs-comment">//第 2 行</span>
    ......
    [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1.</span>.....,<span class="hljs-number">0</span>]    <span class="hljs-comment">//第 16 行</span>
]
</code></pre>
<p>这样的话我们就需要将汉字转换为点阵数组来输出，这就涉及到另一个话题：</p>
<h3 id="-">点阵字库</h3>
<p>在上个世纪的 90 年代，16x16 和 32x32 点阵字库还在 PC 的操作系统和办公软件中使用。而现在，在 PC 上已经看不见点阵字库，基本上点阵字体都被更漂亮的矢量字库取代了。</p>
<p>一开始，我的思路是尝试将系统的宋体 <code>SimSun.ttf</code> 中文字的轮廓提取出来，然后转成点阵。这么做是可以的，只要通过  将文字的 glyf（轮廓）提出来，然后根据矢量转成点阵即可。但是这么做发现在 32x32 下效果还可以，压缩到16x16之后，文字严重失真。分析原因可能是现在的矢量字体并不为低分辨率设计，也可能是我用的压缩算法有问题，不管怎么样，这么做比较难实现。</p>
<p>既然这样的话，那只能换一种思路，直接 可以帮助我们做到。</p>
<p>要提取字库中的文字，也很简单，直接将字符的 unicode 通过 iconv-lite 转成 gbk 编码，然后查找对应的区位即可以定位文件中的位置，详细的转换方式可以参考。查找到文字在文件中的位置后，将其后的 32 个字节输出并转成一个 16x16 的二维数组即可。用 Node.js 实现的代码如下：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">const</span> iconv = <span class="hljs-built_in">require</span>(<span class="hljs-string">"iconv-lite"</span>);
<span class="hljs-keyword">const</span> fontBuffer = fs.readFileSync(__dirname + <span class="hljs-string">"/HZK16"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readText</span>(<span class="hljs-params">text</span>)</span>{
  <span class="hljs-keyword">var</span> ret = [];
  <span class="hljs-keyword">var</span> gbkBytes = iconv.encode(text, <span class="hljs-string">"gbk"</span>);

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; gbkBytes.length / <span class="hljs-number">2</span>; i++){
    <span class="hljs-keyword">var</span> qh = gbkBytes[<span class="hljs-number">2</span> * i] - <span class="hljs-number">0xa0</span>;
    <span class="hljs-keyword">var</span> wh = gbkBytes[<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>] - <span class="hljs-number">0xa0</span>;

    <span class="hljs-keyword">var</span> offset = (<span class="hljs-number">94</span> * (qh - <span class="hljs-number">1</span>) + (wh - <span class="hljs-number">1</span>)) * <span class="hljs-number">32</span>;
    <span class="hljs-keyword">var</span> buff = fontBuffer.slice(offset, offset+<span class="hljs-number">32</span>);
    <span class="hljs-keyword">var</span> font = [];

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++){
      <span class="hljs-keyword">var</span> row = (<span class="hljs-string">"00000000"</span> + buff[<span class="hljs-number">2</span> * j].toString(<span class="hljs-number">2</span>)).slice(<span class="hljs-number">-8</span>)
        + (<span class="hljs-string">"00000000"</span> + buff[<span class="hljs-number">2</span> * j + <span class="hljs-number">1</span>].toString(<span class="hljs-number">2</span>)).slice(<span class="hljs-number">-8</span>);
      row = row.split(<span class="hljs-string">""</span>).map(c=&gt;<span class="hljs-number">0</span>|c);
      font.push(row);
    }
    ret.push(font);
  }

  <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-built_in">module</span>.exports = {readText};
</code></pre>
<h3 id="-">最终将文字显示到点阵屏</h3>
<p>接下来，将文字显示到点阵屏就简单了，方式就如前面的伪代码那样。</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">const</span> Gpio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"rpio2"</span>).Gpio;
<span class="hljs-keyword">var</span> latch = <span class="hljs-keyword">new</span> Gpio(<span class="hljs-number">38</span>);<span class="hljs-comment">//锁存器 </span>
<span class="hljs-keyword">var</span> clk = <span class="hljs-keyword">new</span> Gpio(<span class="hljs-number">40</span>); <span class="hljs-comment">//时钟信号</span>
<span class="hljs-keyword">var</span> red = <span class="hljs-keyword">new</span> Gpio(<span class="hljs-number">36</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">//点阵输出信号</span>
<span class="hljs-keyword">var</span> oe = <span class="hljs-keyword">new</span> Gpio(<span class="hljs-number">32</span>); <span class="hljs-comment">//使能信号</span>
<span class="hljs-keyword">var</span> rows = Gpio.group([<span class="hljs-number">29</span>,<span class="hljs-number">31</span>,<span class="hljs-number">33</span>,<span class="hljs-number">35</span>]);

rows.open(Gpio.OUTPUT, Gpio.LOW); 
rows.value = <span class="hljs-number">0</span>; <span class="hljs-comment">//选行</span>
latch.open(Gpio.OUTPUT, Gpio.HIGH); <span class="hljs-comment">//锁存输出</span>
clk.open(Gpio.OUTPUT, Gpio.LOW);
red.open(Gpio.OUTPUT, Gpio.HIGH);
oe.open(Gpio.OUTPUT, Gpio.HIGH);
rows.value = <span class="hljs-number">0</span>;

<span class="hljs-keyword">const</span> readText = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./lib/font_matrix.js"</span>).readText;
<span class="hljs-keyword">var</span> pixels = readText(<span class="hljs-string">"你好，世界！"</span>);
<span class="hljs-keyword">var</span> startTime = <span class="hljs-built_in">Date</span>.now();

<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>){
  <span class="hljs-keyword">var</span> t = <span class="hljs-built_in">Math</span>.floor((<span class="hljs-built_in">Date</span>.now() - startTime) / <span class="hljs-number">1000</span>);

  data = pixels[t % pixels.length];  <span class="hljs-comment">//1 秒钟换一个字，循环播放</span>

  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">16</span>; j++){    
    latch.value = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++){
      red.value = data[j][<span class="hljs-number">15</span> - i]; <span class="hljs-comment">//注意输入信号从右到左，所以左右要颠倒一下</span>
      clk.value = <span class="hljs-number">0</span>;
      clk.value = <span class="hljs-number">1</span>;
    }
    oe.value = <span class="hljs-number">1</span>;
    rows.value = j;
    latch.value = <span class="hljs-number">1</span>;
    oe.value = <span class="hljs-number">0</span>;
  }
}
</code></pre>
<p>这里面有一个地方要注意，那就是因为设备用的是锁存器，所以输入最早的信号出现在右侧（可以将锁存器想象为一个接收信号的堆栈，当堆栈装满了之后输出，所以最先收到的信号在最后，因此输入的时候要颠倒一下：<code>red.value = data[j][15 - i]</code>）。</p>
<h3 id="-">让文字运动起来</h3>
<p>上面的代码，我们是让点阵屏一秒钟换一个字，循环播放“你好，世界！”。注意到生活中的广告屏（比如公交车上的）都是能让文字移动滚动的，这样更生动一些。那么我们可不可以让文字也滚动循环播放呢？答案当然是可以的。事实上我们很容易能实现这样的动画，实现后的显示效果可以。</p>
<p>具体怎么实现，留给各位小伙伴思考。想到或想不到的，都可以看我的。</p>
<h2 id="-">总结</h2>
<p>通过实战设计电路和编写代码驱动 LED 点阵屏，我们也重新复习或了解了数字电路中的时序和锁频输入输出（LATCH/SCK）的重要概念。利用树莓派和 Node.js 可以很方便地设计硬件和软件来实现有趣的功能。这个小小的点阵屏板，也可以用来做很多事情。有同事就希望可以将它放在车后面，然后用手机控制它输出的文本内容，这个实际上是可以做到的，尤其是通过 WoT（Web of Things），我们可以将各种设备连接到一起。</p>
<p>有任何问题，欢迎留言讨论~</p>
---------------