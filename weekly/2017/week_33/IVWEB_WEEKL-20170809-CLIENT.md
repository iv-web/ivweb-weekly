## 文章索引
1、 <a href="#1android开发周报groovy基础详解android远程调试探索" >Android开发周报：Groovy基础详解、Android远程调试探索</a><br/>
2、 <a href="#2文章-深入聊聊微服务架构的身份认证问题" >文章： 深入聊聊微服务架构的身份认证问题</a><br/>
3、 <a href="#3文章-释放net-big-memory和内存映射文件的能量" >文章： 释放.NET Big Memory和内存映射文件的能量</a><br/>
4、 <a href="#4文章-深入浅出tensroflow七tensorflow计算加速" >文章： 深入浅出TensroFlow（七）TensorFlow计算加速</a><br/>
5、 <a href="#5视频演讲-海尔实时计算平台技术选型与实践" >视频演讲： 海尔实时计算平台技术选型与实践</a><br/>
6、 <a href="#6视频演讲-美团点评旅游推荐系统的演进" >视频演讲： 美团点评旅游推荐系统的演进</a><br/>
7、 <a href="#7从战略和技术角度谈企业转型的思与变" >从战略和技术角度谈企业转型的“思与变”</a><br/>
8、 <a href="#8京东物流系统自动化运维平台技术揭密" >京东物流系统自动化运维平台技术揭密</a><br/>
9、 <a href="#9迷你书-架构师2017年8月" >迷你书： 架构师（2017年8月）</a><br/>
10、 <a href="#10building-a-simple-ai-chatbot-with-web-speech-api-and-nodejs" >Building A Simple AI Chatbot With Web Speech API And Node.js</a><br/>
11、 <a href="#11koa-框架教程" >Koa 框架教程</a><br/>
12、 <a href="#12jetbrains宣布官方支持rust插件" >JetBrains宣布官方支持Rust插件</a><br/>
13、 <a href="#13事件总线实现方式汇总" >事件总线实现方式汇总</a><br/>
14、 <a href="#14云计算平台点兵谁在用aws谁在用azure" >云计算平台点兵：谁在用AWS，谁在用Azure？</a><br/>
15、 <a href="#15tensorfire利用-gpu-加速的浏览器端深度学习框架" >TensorFire：利用 GPU 加速的浏览器端深度学习框架</a><br/>
16、 <a href="#16前端每周清单第-25-期vue2-响应式原理rn-运行内置-nodejs-巧用-proxy-反混淆graphql-优劣思辨深入-react-动画" >前端每周清单第 25 期：Vue2 响应式原理，RN 运行内置 Node，JS 巧用 Proxy 反混淆，GraphQL 优劣思辨，深入 React 动画</a><br/>
17、 <a href="#17how-to-work-out-what-to-charge-clients:-the-honest-version" >How To Work Out What To Charge Clients: The Honest Version</a><br/>
18、 <a href="#18物联网技术周报第-101-期:-创建你自己的私有-lora-网络" >物联网技术周报第 101 期: 创建你自己的私有 LoRa 网络</a><br/><h1 id="#title_0" >1、Android开发周报：Groovy基础详解、Android远程调试探索</h1>
郭亮
[http://www.infoq.com/cn/news/2017/08/Android-weekly-groovy-an?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/08/Android-weekly-groovy-an?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>2017年2季度：Android智能机在美份额持续领先iOS；为了杜绝恶意软件，Google开始为安卓设备部署Play Protect功能。本期周报为大家带来了Gradle、Replugin、Kotlin、远程调试等方面的技术分享，欢迎阅读。</p> <i>By 郭亮</i>
---------------
<h1 id="#title_1" >2、文章： 深入聊聊微服务架构的身份认证问题</h1>
王海龙
[http://www.infoq.com/cn/articles/identity-authentication-of-architecture-in-micro-service?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/identity-authentication-of-architecture-in-micro-service?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/articles/identity-authentication-of-architecture-in-micro-service/zh/smallimage/road.jpg"/><p>从单体应用架构到分布式应用架构再到微服务架构，应用的安全访问在不断的经受考验。为了适应架构的变化、需求的变化，身份认证与鉴权方案也在不断的变革。面对数十个甚至上百个微服务之间的调用，如何保证高效安全的身份认证？面对外部的服务访问，该如何提供细粒度的鉴权方案？本文将会为大家阐述微服务架构下的安全认证与鉴权方案。</p> <i>By 王海龙</i>
---------------
<h1 id="#title_2" >3、文章： 释放.NET Big Memory和内存映射文件的能量</h1>
Dmitriy Khmaladze
[http://www.infoq.com/cn/articles/Big-Memory-Part-3?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/Big-Memory-Part-3?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/articles/Big-Memory-Part-3/zh/headerimage/GettyImages-507957206.jpg"/><p>延续关于.NET平台的Big Memory主题，本文介绍了使用Agincore’s Big Memory Pile在托管CLR服务器环境中使用大型数据集的优势。</p> <i>By Dmitriy Khmaladze</i> <i> Translated by 猫儿不熊</i>
---------------
<h1 id="#title_3" >4、文章： 深入浅出TensroFlow（七）TensorFlow计算加速</h1>
郑泽宇
[http://www.infoq.com/cn/articles/introduction-of-tensorflow-part07?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/introduction-of-tensorflow-part07?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/articles/introduction-of-tensorflow-part07/zh/smallimage/xx_logo (2).jpg"/><p>要将深度学习应用到实际问题中，一个非常大的问题在于训练深度学习模型需要的计算量太大。为了加速训练过程，本文将介绍如何通过TensorFlow利用GPU或/和分布式计算进行模型训练。</p> <i>By 郑泽宇</i>
---------------
<h1 id="#title_4" >5、视频演讲： 海尔实时计算平台技术选型与实践</h1>
肖云
[http://www.infoq.com/cn/presentations/technology-selection-and-practice-of-haier-real-time-computing-platform?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/technology-selection-and-practice-of-haier-real-time-computing-platform?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/presentations/technology-selection-and-practice-of-haier-real-time-computing-platform/zh/mediumimage/xiaoyun270.jpg"/><p>海尔作为一家大型知名企业，每天每时每刻都在产生大量的各类业务运营数据，并且分散在众多的业务系统中，如何实时捕获业务变化数据和汇总，并做实时的洞察分析和可视化的视觉呈现，存在非常多的技术挑战。本次演讲将介绍海尔在多业务系统情况下的实时数据采集、实时消息处理、实时计算处理和数据可视化方面的技术选型与实践，以及对部分开源项目的深度定制和改造的经验。</p> <i>By 肖云</i>
---------------
<h1 id="#title_5" >6、视频演讲： 美团点评旅游推荐系统的演进</h1>
郑刚
[http://www.infoq.com/cn/presentations/evolution-of-us-group-review-tour-recommendation-system?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/evolution-of-us-group-review-tour-recommendation-system?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/presentations/evolution-of-us-group-review-tour-recommendation-system/zh/mediumimage/zhenggang270.jpg"/><p>旅游推荐不同于美食或酒店，用户的兴趣点往往并不明确，旅游推荐面临诸多难题。例如：如何解决度假行前与行中场景的需求差异？如何展示景点门票、线路游等多种推荐形式？如何应对旅游季节变化的特点？如何实现不同用户的个性化推荐和排序？本次演讲会介绍美团点评旅游推荐系统从 0 到 1 完整的演进过程，以及未来的挑战和发展方向。</p> <i>By 郑刚</i>
---------------
<h1 id="#title_6" >7、从战略和技术角度谈企业转型的“思与变”</h1>
薛梁
[http://www.infoq.com/cn/news/2017/08/olm-business-transformation?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/08/olm-business-transformation?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>《周易·系辞下》云，静则思，思则变，变则通，通则达。对于长远发展这个话题，古人已经总结的很好了。</p> <i>By 薛梁</i>
---------------
<h1 id="#title_7" >8、京东物流系统自动化运维平台技术揭密</h1>
郭蕾
[http://www.infoq.com/cn/news/2017/08/jd-automation-operations?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/08/jd-automation-operations?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>以京东为例，它的物流系统有很多分支机构， 比如仓库、分拨中心、转运中心等， 业务复杂的分支机构可能会有自己的信息系统， 这些信息系统往往分布式地部署到全国各地，那如何基于自动化运维平台管理好这些分支机构的服务器、 信息系统， 降低因为地域分布造成的运维维护成本呢？京东资深架构师赵玉开向InfoQ记者深入介绍了他们在自动化运维平台方面的一些探索和实践。</p> <i>By 郭蕾</i>
---------------
<h1 id="#title_8" >9、迷你书： 架构师（2017年8月）</h1>
InfoQ中文站
[http://www.infoq.com/cn/minibooks/architect-201708?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/minibooks/architect-201708?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/minibooks/architect-201708/zh/smallimage/100.jpg"/><p>本期主要内容：Google发布IPv6的应用情况；Java 老矣，尚能饭否？当DevOps遇见AI，智能运维的黄金时代；学会思考，而不只是编程；为什么 AI 工程师要懂一点架构？整洁代码之道——重构</p> <i>By InfoQ中文站</i>
---------------
<h1 id="#title_9" >10、Building A Simple AI Chatbot With Web Speech API And Node.js</h1>
Tomomi Imura
[https://www.smashingmagazine.com/2017/08/ai-chatbot-web-speech-api-node-js/](https://www.smashingmagazine.com/2017/08/ai-chatbot-web-speech-api-node-js/)
<table width="650">
	<tr>
		<td width="650">
			<div style="width:650px;">
				<img src="http://statisches.auslieferung.commindo-media-ressourcen.de/advertisement.gif" alt="" border="0"/>
				<br/>
				<a href="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=target&collection=smashing-rss&position=1" target="_blank">
					<img src="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=image&collection=smashing-rss&position=1" border="0" alt=""/>
				</a>
				&nbsp;
				<a href="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=target&collection=smashing-rss&position=2" target="_blank">
					<img src="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=image&collection=smashing-rss&position=2" border="0" alt=""/>
				</a>
				&nbsp;
				<a href="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=target&collection=smashing-rss&position=3" target="_blank">
					<img src="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=image&collection=smashing-rss&position=3" border="0" alt=""/>
				</a>
			</div>
		</td>
	</tr>
</table><p>Using voice commands has become pretty ubiquitous nowadays, as <strong>more mobile phone users use voice assistants</strong> such as Siri and Cortana, and as devices such as Amazon Echo and Google Home have been invading our living rooms.</p>

<figure></figure>

<p>These systems are built with speech recognition software that allows their users to issue voice commands. Now, our web browsers will become familiar with to Web Speech API, which allows users to integrate voice data in web apps.</p><p>The post .</p>
---------------
<h1 id="#title_10" >11、Koa 框架教程</h1>
阮一峰
[http://www.ruanyifeng.com/blog/2017/08/koa.html](http://www.ruanyifeng.com/blog/2017/08/koa.html)
<p>Node 主要用在开发 Web 应用。这决定了使用 Node，往往离不开 Web 应用框架。</p>

        <p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017080801.png" alt="" title="" /></p>

<p> 就是一种简单好用的 Web 框架。它的特点是优雅、简洁、表达力强、自由度高。本身代码只有1000多行，所有功能都通过插件实现，很符合 Unix 哲学。</p>

<p>本文从零开始，循序渐进，教会你如何使用 Koa 写出自己的 Web 应用。每一步都有简洁易懂的示例，希望让大家一看就懂。</p>

<h2>零、准备</h2>

<p>首先，检查 Node 版本。</p>

<blockquote><pre><code class="language-bash">
$ node -v
v8.0.0
</code></pre></blockquote>

<p>Koa 必须使用 7.6 以上的版本。如果你的版本低于这个要求，就要先升级 Node。</p>

<p>然后，克隆本文的配套解压。）</p>

<blockquote><pre><code class="language-bash">
$ git clone https://github.com/ruanyf/koa-demos.git
</code></pre></blockquote>

<p>接着，进入示例库，安装依赖。</p>

<blockquote><pre><code class="language-bash">
$ cd koa-demos
$ npm install
</code></pre></blockquote>

<p>所有示例源码，都在   目录下面。</p>

<h2>一、基本用法</h2>

<h3>1.1 架设 HTTP 服务</h3>

<p>只要，就可以用 Koa 架设一个 HTTP 服务。</p>

<blockquote><pre><code class="language-javascript">
// demos/01.js
const Koa = require('koa');
const app = new Koa();

app.listen(3000);
</code></pre></blockquote>

<p>运行这个脚本。</p>

<blockquote><pre><code class="language-bash">
$ node demos/01.js
</code></pre></blockquote>

<p>打开浏览器，访问 http://127.0.0.1:3000 。你会看到页面显示"Not Found"，表示没有发现任何内容。这是因为我们并没有告诉 Koa 应该显示什么内容。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017080802.png" alt="" title="" /></p>

<h3>1.2 Context 对象</h3>

<p>Koa 提供一个 Context 对象，表示一次对话的上下文（包括 HTTP 请求和 HTTP 回复）。通过加工这个对象，就可以控制返回给用户的内容。</p>

<p><code>Context.response.body</code>属性就是发送给用户的内容。请看下面的例子（完整的代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/02.js
const Koa = require('koa');
const app = new Koa();

const main = ctx => {
  ctx.response.body = 'Hello World';
};

app.use(main);
app.listen(3000);
</code></pre></blockquote>

<p>上面代码中，<code>main</code>函数用来设置<code>ctx.response.body</code>。然后，使用<code>app.use</code>方法加载<code>main</code>函数。</p>

<p>你可能已经猜到了，<code>ctx.response</code>代表 HTTP Response。同样地，<code>ctx.request</code>代表 HTTP Request。</p>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/02.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，现在就可以看到"Hello World"了。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017080803.png" alt="" title="" /></p>

<h3>1.3 HTTP Response 的类型</h3>

<p>Koa 默认的返回类型是<code>text/plain</code>，如果想返回其他类型的内容，可以先用<code>ctx.request.accepts</code>判断一下，客户端希望接受什么数据（根据 HTTP Request 的<code>Accept</code>字段），然后使用<code>ctx.response.type</code>指定返回类型。请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/03.js
const main = ctx => {
  if (ctx.request.accepts('xml')) {
    ctx.response.type = 'xml';
    ctx.response.body = '&lt;data>Hello World&lt;/data>';
  } else if (ctx.request.accepts('json')) {
    ctx.response.type = 'json';
    ctx.response.body = { data: 'Hello World' };
  } else if (ctx.request.accepts('html')) {
    ctx.response.type = 'html';
    ctx.response.body = '&lt;p>Hello World&lt;/p>';
  } else {
    ctx.response.type = 'text';
    ctx.response.body = 'Hello World';
  }
};
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/03.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，现在看到的就是一个 XML 文档了。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017080804.png" alt="" title="" /></p>

<h3>1.4 网页模板</h3>

<p>实际开发中，返回给用户的网页往往都写成模板文件。我们可以让 Koa 先读取模板文件，然后将这个模板返回给用户。请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/04.js
const fs = require('fs');

const main = ctx => {
  ctx.response.type = 'html';
  ctx.response.body = fs.createReadStream('./demos/template.html');
};
</code></pre></blockquote>

<p>运行这个 Demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/04.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，看到的就是的内容了。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017080805.png" alt="" title="" /></p>

<h2>二、路由</h2>

<h3>2.1 原生路由</h3>

<p>网站一般都有多个页面。通过<code>ctx.request.path</code>可以获取用户请求的路径，由此实现简单的路由。请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/05.js
const main = ctx => {
  if (ctx.request.path !== '/') {
    ctx.response.type = 'html';
    ctx.response.body = '&lt;a href="/">Index Page&lt;/a>';
  } else {
    ctx.response.body = 'Hello World';
  }
};
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/05.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000/about ，可以看到一个链接，点击后就跳到首页。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017080806.png" alt="" title="" /></p>

<h3>2.2 koa-route 模块</h3>

<p>原生路由用起来不太方便，我们可以使用封装好的）。</p>

<blockquote><pre><code class="language-javascript">
// demos/06.js
const route = require('koa-route');

const about = ctx => {
  ctx.response.type = 'html';
  ctx.response.body = '&lt;a href="/">Index Page&lt;/a>';
};

const main = ctx => {
  ctx.response.body = 'Hello World';
};

app.use(route.get('/', main));
app.use(route.get('/about', about));
</code></pre></blockquote>

<p>上面代码中，根路径<code>/</code>的处理函数是<code>main</code>，<code>/about</code>路径的处理函数是<code>about</code>。</p>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/06.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000/about ，效果与上一个例子完全相同。</p>

<h3>2.3 静态资源</h3>

<p>如果网站提供静态资源（图片、字体、样式表、脚本......），为它们一个个写路由就很麻烦，也没必要。）。</p>

<blockquote><pre><code class="language-javascript">
// demos/12.js
const path = require('path');
const serve = require('koa-static');

const main = serve(path.join(__dirname));
app.use(main);
</code></pre></blockquote>

<p>运行这个 Demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/12.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000/12.js，在浏览器里就可以看到这个脚本的内容。</p>

<h3>2.4 重定向</h3>

<p>有些场合，服务器需要重定向（redirect）访问请求。比如，用户登陆以后，将他重定向到登陆前的页面。<code>ctx.response.redirect()</code>方法可以发出一个302跳转，将用户导向另一个路由。请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/13.js
const redirect = ctx => {
  ctx.response.redirect('/');
  ctx.response.body = '&lt;a href="/">Index Page&lt;/a>';
};

app.use(route.get('/redirect', redirect));
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/13.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000/redirect ，浏览器会将用户导向根路由。</p>

<h2>三、中间件</h2>

<h3>3.1 Logger 功能</h3>

<p>Koa 的最大特色，也是最重要的一个设计，就是中间件（middleware）。为了理解中间件，我们先看一下 Logger （打印日志）功能的实现。</p>

<p>最简单的写法就是在<code>main</code>函数里面增加一行（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/07.js
const main = ctx => {
  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);
  ctx.response.body = 'Hello World';
};
</code></pre></blockquote>

<p>运行这个 Demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/07.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，命令行就会输出日志。</p>

<blockquote><pre><code class="language-bash">
1502144902843 GET /
</code></pre></blockquote>

<h3>3.2 中间件的概念</h3>

<p>上一个例子里面的 Logger 功能，可以拆分成一个独立函数（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/08.js
const logger = (ctx, next) => {
  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);
  next();
}
app.use(logger);
</code></pre></blockquote>

<p>像上面代码中的<code>logger</code>函数就叫做"中间件"（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。<code>app.use()</code>用来加载中间件。</p>

<p>基本上，Koa 所有的功能都是通过中间件实现的，前面例子里面的<code>main</code>也是中间件。每个中间件默认接受两个参数，第一个参数是 Context 对象，第二个参数是<code>next</code>函数。只要调用<code>next</code>函数，就可以把执行权转交给下一个中间件。</p>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/08.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，命令行窗口会显示与上一个例子相同的日志输出。</p>

<h3>3.3 中间件栈</h3>

<p>多个中间件会形成一个栈结构（middle stack），以"先进后出"（first-in-last-out）的顺序执行。</p>

<blockquote>
  <ol start='1'>
<li>最外层的中间件首先执行。</li>
<li>调用<code>next</code>函数，把执行权交给下一个中间件。</li>
<li>...</li>
<li>最内层的中间件最后执行。</li>
<li>执行结束后，把执行权交回上一层的中间件。</li>
<li>...</li>
<li>最外层的中间件收回执行权之后，执行<code>next</code>函数后面的代码。</li>
</ol>
</blockquote>

<p>请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/09.js
const one = (ctx, next) => {
  console.log('>> one');
  next();
  console.log('&lt;&lt; one');
}

const two = (ctx, next) => {
  console.log('>> two');
  next(); 
  console.log('&lt;&lt; two');
}

const three = (ctx, next) => {
  console.log('>> three');
  next();
  console.log('&lt;&lt; three');
}

app.use(one);
app.use(two);
app.use(three);

</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/09.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，命令行窗口会有如下输出。</p>

<blockquote><pre><code class="language-bash">
>> one
>> two
>> three
&lt;&lt; three
&lt;&lt; two
&lt;&lt; one
</code></pre></blockquote>

<p>如果中间件内部没有调用<code>next</code>函数，那么执行权就不会传递下去。作为练习，你可以将<code>two</code>函数里面<code>next()</code>这一行注释掉再执行，看看会有什么结果。</p>

<h3>3.4 异步中间件</h3>

<p>迄今为止，所有例子的中间件都是同步的，不包含异步操作。如果有异步操作（比如读取数据库），中间件就必须写成 ）。</p>

<blockquote><pre><code class="language-javascript">
// demo02/10.js
const fs = require('fs.promised');
const Koa = require('koa');
const app = new Koa();

const main = async function (ctx, next) {
  ctx.response.type = 'html';
  ctx.response.body = await fs.readFile('./demos/template.html', 'utf8');
};

app.use(main);
app.listen(3000);
</code></pre></blockquote>

<p>上面代码中，<code>fs.readFile</code>是一个异步操作，必须写成<code>await fs.readFile()</code>，然后中间件必须写成 async 函数。</p>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/10.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，就可以看到模板文件的内容。</p>

<h3>3.5 中间件的合成</h3>

<p>）。</p>

<blockquote><pre><code class="language-javascript">
// demos/11.js
const compose = require('koa-compose');

const logger = (ctx, next) => {
  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);
  next();
}

const main = ctx => {
  ctx.response.body = 'Hello World';
};

const middlewares = compose([logger, main]);
app.use(middlewares);
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/11.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，就可以在命令行窗口看到日志信息。</p>

<h2>四、错误处理</h2>

<h3>4.1 500 错误</h3>

<p>如果代码运行过程中发生错误，我们需要把错误信息返回给用户。HTTP 协定约定这时要返回500状态码。Koa 提供了<code>ctx.throw()</code>方法，用来抛出错误，<code>ctx.throw(500)</code>就是抛出500错误。请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/14.js
const main = ctx => {
  ctx.throw(500);
};
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/14.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000，你会看到一个500错误页"Internal Server Error"。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017080807.png" alt="" title="" /></p>

<h3>4.2 404错误</h3>

<p>如果将<code>ctx.response.status</code>设置成404，就相当于<code>ctx.throw(404)</code>，返回404错误。请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/15.js
const main = ctx => {
  ctx.response.status = 404;
  ctx.response.body = 'Page Not Found';
};
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/15.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，你就看到一个404页面"Page Not Found"。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017080808.png" alt="" title="" /></p>

<h3>4.3 处理错误的中间件</h3>

<p>为了方便处理错误，最好使用<code>try...catch</code>将其捕获。但是，为每个中间件都写<code>try...catch</code>太麻烦，我们可以让最外层的中间件，负责所有中间件的错误处理。请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/16.js
const handler = async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.body = {
      message: err.message
    };
  }
};

const main = ctx => {
  ctx.throw(500);
};

app.use(handler);
app.use(main);
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/16.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，你会看到一个500页，里面有报错提示 <code>{"message":"Internal Server Error"}</code>。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017080809.png" alt="" title="" /></p>

<h3>4.4 error 事件的监听</h3>

<p>运行过程中一旦出错，Koa 会触发一个<code>error</code>事件。监听这个事件，也可以处理错误。请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/17.js
const main = ctx => {
  ctx.throw(500);
};

app.on('error', (err, ctx) =>
  console.error('server error', err);
);
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/17.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，你会在命令行窗口看到"server error xxx"。</p>

<h3>4.5 释放 error 事件</h3>

<p>需要注意的是，如果错误被<code>try...catch</code>捕获，就不会触发<code>error</code>事件。这时，必须调用<code>ctx.app.emit()</code>，手动释放<code>error</code>事件，才能让监听函数生效。请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/18.js`
const handler = async (ctx, next) => {
  try {
    await next();
  } catch (err) {
    ctx.response.status = err.statusCode || err.status || 500;
    ctx.response.type = 'html';
    ctx.response.body = '&lt;p>Something wrong, please contact administrator.&lt;/p>';
    ctx.app.emit('error', err, ctx);
  }
};

const main = ctx => {
  ctx.throw(500);
};

app.on('error', function(err) {
  console.log('logging error ', err.message);
  console.log(err);
});
</code></pre></blockquote>

<p>上面代码中，<code>main</code>函数抛出错误，被<code>handler</code>函数捕获。<code>catch</code>代码块里面使用<code>ctx.app.emit()</code>手动释放<code>error</code>事件，才能让监听函数监听到。</p>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/18.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，你会在命令行窗口看到<code>logging error</code>。</p>

<h2>五、Web App 的功能</h2>

<h3>5.1  Cookies</h3>

<p><code>ctx.cookies</code>用来读写 Cookie。请看下面的例子（完整代码看）。</p>

<blockquote><pre><code class="language-javascript">
// demos/19.js
const main = function(ctx) {
  const n = Number(ctx.cookies.get('view') || 0) + 1;
  ctx.cookies.set('view', n);
  ctx.response.body = n + ' views';
}
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/19.js
</code></pre></blockquote>

<p>访问 http://127.0.0.1:3000 ，你会看到<code>1 views</code>。刷新一次页面，就变成了<code>2 views</code>。再刷新，每次都会计数增加1。</p>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017080810.png" alt="" title="" /></p>

<h3>5.2 表单</h3>

<p>Web 应用离不开处理表单。本质上，表单就是 POST 方法发送到服务器的键值对。）。</p>

<blockquote><pre><code class="language-javascript">
// demos/20.js
const koaBody = require('koa-body');

const main = async function(ctx) {
  const body = ctx.request.body;
  if (!body.name) ctx.throw(400, '.name required');
  ctx.body = { name: body.name };
};

app.use(koaBody());
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/20.js
</code></pre></blockquote>

<p>打开另一个命令行窗口，运行下面的命令。</p>

<blockquote><pre><code class="language-bash">
$ curl -X POST --data "name=Jack" 127.0.0.1:3000
{"name":"Jack"}

$ curl -X POST --data "name" 127.0.0.1:3000
name required
</code></pre></blockquote>

<p>上面代码使用 POST 方法向服务器发送一个键值对，会被正确解析。如果发送的数据不正确，就会收到错误提示。</p>

<h3>2.3 文件上传</h3>

<p>）。</p>

<blockquote><pre><code class="language-javascript">
// demos/21.js
const os = require('os');
const path = require('path');
const koaBody = require('koa-body');

const main = async function(ctx) {
  const tmpdir = os.tmpdir();
  const filePaths = [];
  const files = ctx.request.body.files || {};

  for (let key in files) {
    const file = files[key];
    const filePath = path.join(tmpdir, file.name);
    const reader = fs.createReadStream(file.path);
    const writer = fs.createWriteStream(filePath);
    reader.pipe(writer);
    filePaths.push(filePath);
  }

  ctx.body = filePaths;
};

app.use(koaBody({ multipart: true }));
</code></pre></blockquote>

<p>运行这个 demo。</p>

<blockquote><pre><code class="language-bash">
$ node demos/21.js
</code></pre></blockquote>

<p>打开另一个命令行窗口，运行下面的命令，上传一个文件。注意，<code>/path/to/file</code>要更换为真实的文件路径。</p>

<blockquote><pre><code class="language-bash">
$ curl --form upload=@/path/to/file http://127.0.0.1:3000
["/tmp/file"]
</code></pre></blockquote>

<h2>六、参考链接</h2>

<ul>
<li></li>
<li></li>
<li></li>
</ul>

<p>（完）</p>

        <div style="color:#556677;line-height:160%;padding:0.3em 0.5em;border:1px solid #d3d3d3;margin:1em;background-color:#AAD2F0;-moz-border-radius: 10px;-webkit-border-radius:10px;border-radius: 10px;"><h3>文档信息</h3>
<ul>
<li>版权声明：自由转载-非商用-非衍生-保持署名（）</li>
<li>发表日期： <abbr class="published" title="2017-08-09T07:29:00+08:00">2017年8月 9日</abbr></li>
<li>更多内容：   » 
 
</li>
<li>博客文集：</li>
<li>社交媒体：</li>
<li>Feed订阅： </li>

</ul></div>        
        <div style="color:#556677;line-height:160%;padding:0.3em 0.5em;margin:1em;-moz-border-radius: 10px;-webkit-border-radius:10px;border-radius: 10px;"></div>
---------------
<h1 id="#title_11" >12、JetBrains宣布官方支持Rust插件</h1>
薛命灯
[http://www.infoq.com/cn/news/2017/08/JetBrains-publish-rust?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/08/JetBrains-publish-rust?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>7月31号，Rust社区就已非正式声称JetBrains开始官方支持Rust插件。8月4号，JetBrains官方博客正式宣布开始官方支持Rust插件，包括IDEA、CLion等IntelliJ平台IDE。</p> <i>By 薛命灯</i>
---------------
<h1 id="#title_12" >13、事件总线实现方式汇总</h1>
Mustafa Turan
[http://www.infoq.com/cn/news/2017/08/Summary-event-bus-implementation?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/08/Summary-event-bus-implementation?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>基于事件驱动的分布式异步架构模式多用于构建高可伸缩的反应式应用程序，适用于各种从简单到复杂的应用场景。它的核心思想是去耦合，将消息的发送和接收分开，实现异步处理消息事件。架构师Mustafa Turan在Hackernoon上分享了事件总线的几种实现方式，并总结了每一种实现方式的优缺点。</p> <i>By Mustafa Turan</i> <i> Translated by 薛命灯</i>
---------------
<h1 id="#title_13" >14、云计算平台点兵：谁在用AWS，谁在用Azure？</h1>
Beining
[http://www.infoq.com/cn/news/2017/08/who-aws-azure?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/08/who-aws-azure?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>云计算平台点兵：谁在用AWS，谁在用Azure？Stack Overflow使用访问数据对两家云计算领跑者进行了详细分析。</p> <i>By Beining</i>
---------------
<h1 id="#title_14" >15、TensorFire：利用 GPU 加速的浏览器端深度学习框架</h1>
王下邀月熊
[http://www.infoq.com/cn/news/2017/08/TensorFire-use-GPU-fast-study?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/08/TensorFire-use-GPU-fast-study?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>TensorFire 是基于 WebGL 的运行在浏览器内的高性能神经网络框架，其执行速度甚至可以快于原生的 TensorFlow。</p> <i>By 王下邀月熊</i>
---------------
<h1 id="#title_15" >16、前端每周清单第 25 期：Vue2 响应式原理，RN 运行内置 Node，JS 巧用 Proxy 反混淆，GraphQL 优劣思辨，深入 React 动画</h1>
王下邀月熊
[http://www.infoq.com/cn/news/2017/08/arch-weekly-25?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/08/arch-weekly-25?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>前端每周清单第 25 期：Vue2 响应式原理，RN 运行内置 Node，JS 巧用 Proxy 反混淆，GraphQL 优劣思辨，深入 React 动画</p> <i>By 王下邀月熊</i>
---------------
<h1 id="#title_16" >17、How To Work Out What To Charge Clients: The Honest Version</h1>
Paul Boag
[https://www.smashingmagazine.com/2017/08/what-to-charge-clients/](https://www.smashingmagazine.com/2017/08/what-to-charge-clients/)
<table width="650">
	<tr>
		<td width="650">
			<div style="width:650px;">
				<img src="http://statisches.auslieferung.commindo-media-ressourcen.de/advertisement.gif" alt="" border="0"/>
				<br/>
				<a href="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=target&collection=smashing-rss&position=1" target="_blank">
					<img src="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=image&collection=smashing-rss&position=1" border="0" alt=""/>
				</a>
				&nbsp;
				<a href="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=target&collection=smashing-rss&position=2" target="_blank">
					<img src="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=image&collection=smashing-rss&position=2" border="0" alt=""/>
				</a>
				&nbsp;
				<a href="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=target&collection=smashing-rss&position=3" target="_blank">
					<img src="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=image&collection=smashing-rss&position=3" border="0" alt=""/>
				</a>
			</div>
		</td>
	</tr>
</table><p>Have you ever read a post that has left you feeling wholly inadequate because you know you can't live up to the high standards they layout? Well, that is how I feel when I read posts about how much to charge my clients.</p>

<figure></figure>

<p>When Smashing Magazine asked me to write an article <strong>sharing my thoughts on pricing my services</strong>, I agreed without much thought. But now I sit down to write it, and I'm faced with a conundrum. Do I write about how you <em>should</em> price projects or do I tell you the truth about the unorthodox approach I take?</p><p>The post .</p>
---------------
<h1 id="#title_17" >18、物联网技术周报第 101 期: 创建你自己的私有 LoRa 网络</h1>
黄峰达
[http://www.infoq.com/cn/news/2017/08/iot-weekly-101?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/08/iot-weekly-101?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>创建你自己的私有 LoRa 网络；如何基于 Android Things 构建一个智能家居系统；使用 Raspberry Pi 3 构建一个杀手级的 Amiga 模拟器；Arduino易主，迎来新时代；Kickstarter CEO 年底离职，三位创始人无一留任；开创全新硬件的野心！Facebook研发智能视频聊天设备</p> <i>By 黄峰达</i>
---------------