## 文章索引
1、 <a href="#1文章-基于reswift和app-coordinator的ios架构" >文章： 基于ReSwift和App Coordinator的iOS架构</a><br/>
2、 <a href="#2mailkit正式替换了net的smtpclient" >MailKit正式替换了.NET的SmtpClient</a><br/>
3、 <a href="#3文章-借助性能优化促进用户数增长" >文章： 借助性能优化促进用户数增长</a><br/>
4、 <a href="#42017年会是serverless爆发之年吗" >2017年会是Serverless爆发之年吗？</a><br/>
5、 <a href="#5net或将引入类型类和扩展" >.NET或将引入类型类和扩展</a><br/>
6、 <a href="#6visual-studio-2017更新侧重于提高稳定性" >Visual Studio 2017更新，侧重于提高稳定性</a><br/>
7、 <a href="#7react-155带来重大修改" >React 15.5带来重大修改</a><br/>
8、 <a href="#8视频演讲-ltrlearning-to-rank在个性化电商搜索领域的应用" >视频演讲： LTR（Learning To Rank）在个性化电商搜索领域的应用</a><br/>
9、 <a href="#9为什么我们要做一本可能不是畅销书的书" >为什么我们要做一本可能不是畅销书的书？</a><br/>
10、 <a href="#10使用-babel-插件来打造真正的私有属性" >使用 babel 插件来打造真正的“私有”属性</a><br/>
11、 <a href="#11how-to-prototype-iot-experiences:-configuring-the-software-part-2" >How To Prototype IoT Experiences: Configuring The Software (Part 2)</a><br/><h1 id="#title_0" >1、文章： 基于ReSwift和App Coordinator的iOS架构</h1>
刘先宁
[http://www.infoq.com/cn/articles/ios-arch-based-on-reswift-and-app-coordinator?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/ios-arch-based-on-reswift-and-app-coordinator?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/articles/ios-arch-based-on-reswift-and-app-coordinator/zh/smallimage/article-logo.jpg"/><p>本文则想从另一个角度和大家探讨一个新的iOS应用架构方案，架构的本质是管理复杂性，在讨论具体的架构方案前，我们首先应该明确一个iOS应用的开发，其复杂性在哪里?</p> <i>By 刘先宁</i>
---------------
<h1 id="#title_1" >2、MailKit正式替换了.NET的SmtpClient</h1>
Jonathan Allen
[http://www.infoq.com/cn/news/2017/04/MailKit-MimeKit-Official?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/04/MailKit-MimeKit-Official?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>SmtpClient的文档现已改成：“废弃（“SmtpClient及其相关类型设计很差，我们强烈建议使用MailKit和MimeKit替代。”）”。这是Microsoft有史以来第二次将一个.NET类正式标为被开源软件库替代。</p> <i>By Jonathan Allen</i> <i> Translated by Rays</i>
---------------
<h1 id="#title_2" >3、文章： 借助性能优化促进用户数增长</h1>
Sam Meder, Vadim Antonov, Jeff
[http://www.infoq.com/cn/articles/driving-user-growth-with-performance-improvements?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/articles/driving-user-growth-with-performance-improvements?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/articles/driving-user-growth-with-performance-improvements/zh/smallimage/logo-net.jpg"/><p>本文介绍了Pinterest通过重写整个前端引擎、所有页面模版，以及通用元素提高页面性能，实现用户数量最大化增长所采取的方法以及从中获得的经验。</p> <i>By Sam Meder</i> <i> Translated by 大愚若智</i>
---------------
<h1 id="#title_3" >4、2017年会是Serverless爆发之年吗？</h1>
麦克周
[http://www.infoq.com/cn/news/2017/04/2017-Serverless?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/04/2017-Serverless?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>在目前主流云计算IaaS（Infrastructure-as-a-Service，基础设施即服务）和PaaS（Platform-as-a-Service，平台即服务）中，开发人员进行业务开发时，仍然需要关心很多和服务器相关的服务端开发工作，比如缓存、消息服务、Web应用服务器、数据库，以及对服务器进行性能优化，还需要考虑存储和计算资源，考虑负载均衡和横向扩展能力，考虑服务器容灾稳定性等非专业逻辑的开发。这些服务器的运维和开发知识、经验极大地限制了开发者进行业务开发的效率。设想一下，如果开发者直接租用服务或者开发服务而无须关注如何在服务器中运行部署服务，是否可以极大地提升开发效率和产品质量？这种去服务器而直接使用服务的架构，我们称之为Serverless架构（无服务器架构）。</p> <i>By 麦克周</i>
---------------
<h1 id="#title_4" >5、.NET或将引入类型类和扩展</h1>
Jonathan Allen
[http://www.infoq.com/cn/news/2017/04/DotNet-Type-Classes?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/04/DotNet-Type-Classes?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>类型类是另外一项正被考虑引入.NET未来版本的特性。在提案“外观和扩展（Shapes and Extensions）”中，该特性被称为外观，它们将大幅提升.NET泛型的能力。</p> <i>By Jonathan Allen</i> <i> Translated by 谢丽</i>
---------------
<h1 id="#title_5" >6、Visual Studio 2017更新，侧重于提高稳定性</h1>
Jeff Martin
[http://www.infoq.com/cn/news/2017/04/vs2017-15.1?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/04/vs2017-15.1?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/news/2017/04/vs2017-15.1/zh/headerimage/GettyImages-477907720.jpg"/><p>Microsoft已对其旗舰开发软件产品Visual Studio 2017（VS2017）的安装程序和设置引擎做了全新设计，意在能快速地部署更新到VS2017。VS2017的第一个命名版本更新在VS2017首发的一个月后就可用，这充分体现了这一全新设计的优势所在。</p> <i>By Jeff Martin</i> <i> Translated by Rays</i>
---------------
<h1 id="#title_6" >7、React 15.5带来重大修改</h1>
David Iffland
[http://www.infoq.com/cn/news/2017/04/React-15-5-deprecations?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/04/React-15-5-deprecations?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>Facebook发布了React 15.5。该版本弃用了两个可能会让开发人员犯错误的特性。Facebook将在版本16中删除这两个特性视为重大更新，为了做好准备，他们希望可以反复告知开发人员需要对自己代码做什么样的修改。</p> <i>By David Iffland</i> <i> Translated by 谢丽</i>
---------------
<h1 id="#title_7" >8、视频演讲： LTR（Learning To Rank）在个性化电商搜索领域的应用</h1>
吴晨
[http://www.infoq.com/cn/presentations/learning-to-rank-in-the-field-of-personalized-electric-business-search?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/presentations/learning-to-rank-in-the-field-of-personalized-electric-business-search?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/presentations/learning-to-rank-in-the-field-of-personalized-electric-business-search/zh/mediumimage/wuchen270.jpg"/><p>随着个性化搜索的技术发展及在电商领域的实践，排序策略，即如何将用户需要且质量度高商品排到合适位置；如何调节不同卖家流量；给质量好，且价格相对合适的商品更多流量，成为近年来研究的热门。传统的规则策略或仅依赖几个关键因素并寻求平衡的排序方案已很难达到较好的效果（特别在引入个性化特征后），因此，Learning to rank，结合检索，点击，展现日志，并通过机器学习模型来学习排序策略的方式，逐渐成为新的发展方向。
本次分享中，我们将讨论 LTR 的若干算法，特征工程（包括个性化特征等），标注样本构建抽样等方案，以及目前电商搜索领域常用的 Query-Full 和 Query-Less 场景中算法及特征选型思路。

</p> <i>By 吴晨</i>
---------------
<h1 id="#title_8" >9、为什么我们要做一本可能不是畅销书的书？</h1>
Betty
[http://www.infoq.com/cn/news/2017/04/book-talk-architecture?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global](http://www.infoq.com/cn/news/2017/04/book-talk-architecture?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global)
<img src="http://www.infoq.com/resource/news/2017/04/book-talk-architecture/zh/headerimage/logo (6).jpg"/><p>这是InfoQ的第一个十年，这是我们做的第一本书，我们今天想给你讲一个有关初心的故事：为什么我们要做一本注定不是畅销书的书？</p> <i>By Betty</i>
---------------
<h1 id="#title_9" >10、使用 babel 插件来打造真正的“私有”属性</h1>

[https://www.h5jun.com/post/babel-plugin-private.html](https://www.h5jun.com/post/babel-plugin-private.html)
<div class="toc"><ul>
<li></li>
<li><ul>
<li></li>
</ul>
</li>
</ul>
</div><p>大家都知道 JavaScript 的对象属性默认是可以被从外部访问和修改的，也就是说，JavaScript 本身不存在完全“私有”的对象属性。例如：</p>
<pre><code class="hljs lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>{
    <span class="hljs-keyword">constructor</span>(x, y){
        <span class="hljs-keyword">this</span>._x = x;
        <span class="hljs-keyword">this</span>._y = y;
    }
    get length(){
        <span class="hljs-keyword">const</span> {_x, _y} = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(_x * _x + _y * _y);
    }
}

<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-built_in">console</span>.log(p._x, p._y, p.length); <span class="hljs-comment">//3, 4, 5</span>
</code></pre>
<p>在上面的代码里，我们<strong>约定俗成</strong>地用下划线开头来表示私有变量。我们希望 _x、_y 不被外部访问，然而，这只是我们一厢情愿，使用者还是可以访问到这两个变量。</p>
<p>在这里，我们不讨论 ES 的 ，而是讨论如何使用工具来将约定变成真正的私有。</p>
<!--more-->
<h2>使用 Symbol 来构造私有数据</h2>
<p>ES6 提供了一个新的数据类型叫做 ，其中一个用途是可以用来生成唯一 key，用作属性标识，我们利用它可以实现真正的私有属性：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">const</span> [_x, _y] = [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'_x'</span>), <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'_y'</span>)];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span>{
    <span class="hljs-keyword">constructor</span>(x, y){
        <span class="hljs-keyword">this</span>[_x] = x;
        <span class="hljs-keyword">this</span>[_y] = y;
    }
    get length(){
        <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">this</span>[_x], 
              y = <span class="hljs-keyword">this</span>[_y];

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(x * x + y * y);
    }
}

<span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-built_in">console</span>.log(p._x, p._y, p.length); <span class="hljs-comment">//undefined, undefined, 5</span>
</code></pre>
<p>我们改写上一版的代码，用 Symbol 的 _x、_y 代替字符串来作为 key，这样，外部 p 访问 _x、_y 属性就访问不到了，这样我们就真正实现了对象数据的私有。</p>
<p>上面这种用法并不复杂，但是，如果我们每次定义对象都这么去写还是显得麻烦。因此，我们可以考虑让编译器去做这件事情，自动将下划线开头的属性编译成私有属性。</p>
<h2>使用 Babel 插件来实现属性的默认私有</h2>
<p>在这里，我们可以开发 。如果对于 Babel 不熟悉的同学，可以回顾一下之前的文章。</p>
<p>首先，我们分析一下要处理的 AST 部分。ES6 的 class 有两种 node 类型，一种是 ClassDeclaration，另一种是 ClassExpression。它们比较类似，但是在一些细节上又有区别。比如 ReturnStatement 之后可以跟 ClassExpression 但是不能跟 ClassDeclaration。</p>
<p><em>ClassDeclaration 与 ClassExpression</em></p>
<pre><code class="hljs lang-js"><span class="hljs-comment">//ClassDeclaration</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>{
 <span class="hljs-comment">//...</span>
}

<span class="hljs-comment">//classExpression</span>
<span class="hljs-keyword">const</span> Bar = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>{
  <span class="hljs-comment">//...</span>
}
</code></pre>
<p>对这两种 node，如果其中有下划线开头的属性，可以分别编译成如下形式：</p>
<pre><code class="hljs lang-actionscript"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  [...fields] = [...Symbol(...)]
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
    <span class="hljs-comment">//...</span>
  }
  <span class="hljs-keyword">return</span> Foo;
}();

<span class="hljs-keyword">const</span> Bar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  [...fields] = [...Symbol(...)]
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>{
    <span class="hljs-comment">//...</span>
  }
}();
</code></pre><p>此外，还需要考虑 ES Modules 的情况：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>{
  <span class="hljs-comment">//...</span>
}
</code></pre>
<p>对应为：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-comment">//...</span>
}();
</code></pre>
<p>上面的形式没有问题。但是如果：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>{
  <span class="hljs-comment">//...</span>
}
</code></pre>
<p>对应为：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> Foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-comment">//...</span>
}();
</code></pre>
<p>编译会报错。因此要进行修改，对应成：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-comment">//...</span>
}();
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Foo;
</code></pre>
<p>由于 Class 允许存在嵌套，因此，我们需要使用堆栈结构，在 AST 的 enter 的时候创建存放当前 Class 的 scope 下的私有属性列表。堆栈还有一个作用，就是如果堆栈为空，那么当前作用域不在 Class 内部，不用进行编译转换。</p>
<pre><code class="hljs lang-js">    ClassDeclaration: {
      exit(path){
        <span class="hljs-keyword">let</span> expr = transformWrapClass(path.node);
        <span class="hljs-keyword">if</span>(!expr) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">if</span>(path.parentPath.node.type === <span class="hljs-string">'ExportDefaultDeclaration'</span>){
          <span class="hljs-comment">//处理 export default 的特殊情况</span>
          path.parentPath.insertAfter(t.exportDefaultDeclaration(
            t.identifier(path.node.id.name)
          ));
          path.parentPath.replaceWith(expr);
        }<span class="hljs-keyword">else</span>{
          <span class="hljs-comment">//替换掉当前 path</span>
          path.replaceWith(expr);
        }

        path.skip();
      },
      enter(path, state){
           <span class="hljs-comment">//创建存放私有变量标识符的堆栈</span>
        stack.push({
          variables: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
        });
      }
    },
    ClassExpression: {
      exit(path){
        <span class="hljs-keyword">let</span> expr = transformWrapClass(path.node);
        <span class="hljs-keyword">if</span>(!expr) <span class="hljs-keyword">return</span>;

        <span class="hljs-comment">//ClassExpression 可以直接 export default</span>
        path.replaceWith(expr);

        path.skip();
      },      
      enter(path, state){
        stack.push({
          variables: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()
        });
      }    
    }
</code></pre>
<p>接下来，我们处理具体的 Identifier：</p>
<pre><code class="hljs lang-js">    Identifier(path, state) {
      <span class="hljs-keyword">if</span>(stack.length &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//不在 class 作用域内，直接返回 </span>
      <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/^__.*__$/</span>.test(path.node.name)) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//系统保留属性，比如 __proto__</span>

      <span class="hljs-keyword">let</span> node = path.node,
          parentNode = path.parentPath.node,
          meta = stack[stack.length - <span class="hljs-number">1</span>];

      <span class="hljs-keyword">let</span> regExp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(state.opts.pattern || <span class="hljs-string">'^_'</span>);

      <span class="hljs-comment">//给属性名增加前缀后缀，避免内部使用时出现重名</span>
      <span class="hljs-comment">//比如应当允许 let _x = this._x;</span>
      <span class="hljs-keyword">let</span> symbolName = <span class="hljs-string">'$'</span> + node.name + <span class="hljs-string">'$'</span>; 

      <span class="hljs-keyword">if</span>(parentNode 
         &amp;&amp; parentNode.type === <span class="hljs-string">'MemberExpression'</span> 
         &amp;&amp; parentNode.object.type === <span class="hljs-string">'ThisExpression'</span>
         &amp;&amp; !parentNode.computed
         &amp;&amp; regExp.test(node.name)){ <span class="hljs-comment">//private</span>

        <span class="hljs-comment">//对于私有属性的读写 this._x，直接替换成 this[_x]</span>
        <span class="hljs-comment">//并且记录下当前变量标识符，添加到栈顶的 Set 中去</span>
        node.name = symbolName;
        meta.variables.add(node.name);
        parentNode.computed = <span class="hljs-literal">true</span>;
      }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(parentNode 
         &amp;&amp; parentNode.type === <span class="hljs-string">'MemberExpression'</span> 
         &amp;&amp; parentNode.object.type === <span class="hljs-string">'Super'</span>
         &amp;&amp; !parentNode.computed
         &amp;&amp; regExp.test(node.name)){

        <span class="hljs-comment">//使用 super._x 访问父元素的属性，进行一个变换</span>
        node.name = symbolName;
        parentNode.computed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">let</span> expr = transformPropertyToSymbol(node.name);
        path.replaceWith(expr);
        path.skip();
      }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(parentNode 
         &amp;&amp; parentNode.type === <span class="hljs-string">'ClassMethod'</span> 
         &amp;&amp; regExp.test(node.name)){

        <span class="hljs-comment">//处理 class 的方法和 getter、setter 名带下划线的情况。</span>
        node.name = symbolName;
        meta.variables.add(node.name);
        parentNode.computed = <span class="hljs-literal">true</span>;
      }
    },
</code></pre>
<h3>Protected 的属性和 super._x 操作</h3>
<p>对于对象方法带下划线的情况，和 this 带下划线不同，我们是可以使用 super.属性名 来访问的。比如：</p>
<pre><code class="hljs lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>{
    <span class="hljs-keyword">constructor</span>(x) {
        <span class="hljs-keyword">this</span>._x = x;
    }
    <span class="hljs-comment">//这是一个 protected 的属性，在派生类中可以通过 super._X 访问</span>
    get _X(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._x;
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>{
  <span class="hljs-keyword">constructor</span>(x, y){
      <span class="hljs-keyword">super</span>(x);
      <span class="hljs-keyword">this</span>._y = y;
  }
  get XY(){
      <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span>._X, <span class="hljs-keyword">this</span>._y];
  }
}

<span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">new</span> Bar(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-built_in">console</span>.log(bar.XY); <span class="hljs-comment">//[3, 4]</span>
</code></pre>
<p>在这里，我们需要对 super._X 进行处理，如果直接编译：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [$_x$, $_X$] = [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'$_x$'</span>), <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'$_X$'</span>)];

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>{
        <span class="hljs-keyword">constructor</span>(x) {
            <span class="hljs-keyword">this</span>[$_x$] = x;
        }
        <span class="hljs-comment">//这是一个 protected 的属性，在派生类中可以通过 super._X 访问</span>
        get [$_X$](){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[$_x$];
        }
    }
    <span class="hljs-keyword">return</span> Foo;
}();

<span class="hljs-keyword">const</span> Bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [$_y$, $_X$] = [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'$_y$'</span>), <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'$_X$'</span>)];
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>{
      <span class="hljs-keyword">constructor</span>(x, y){
          <span class="hljs-keyword">super</span>(x);
          <span class="hljs-keyword">this</span>[$_y$] = y;
      }
      get XY(){
          <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span>[$_X$], <span class="hljs-keyword">this</span>[$_y$]];
      }
    }
    <span class="hljs-keyword">return</span> Bar;
}();

<span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">new</span> Bar(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-built_in">console</span>.log(bar.XY); <span class="hljs-comment">//[undefined, 4]</span>
</code></pre>
<p>由于每个 Symbol 都是唯一的，所以 Bar 的 Symbol(&#39;$_X$&#39;) 和 Foo 的并不相同，这样也就获取不到 super[$_X$] 实际的值了。</p>
<p>因此，在这里，我们编译的时候不能直接这样转成 Symbol，而是要通过反射机制去处理：</p>
<pre><code class="hljs lang-js"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [$_x$, $_X$] = [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'$_x$'</span>), <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'$_X$'</span>)];

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>{
        <span class="hljs-keyword">constructor</span>(x) {
            <span class="hljs-keyword">this</span>[$_x$] = x;
        }
        <span class="hljs-comment">//这是一个 protected 的属性，在派生类中可以通过 super._X 访问</span>
        get [$_X$](){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[$_x$];
        }
    }
    <span class="hljs-keyword">return</span> Foo;
}();

<span class="hljs-keyword">const</span> Bar = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> [$_y$] = [<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'$_y$'</span>)];
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>{
      <span class="hljs-keyword">constructor</span>(x, y){
          <span class="hljs-keyword">super</span>(x);
          <span class="hljs-keyword">this</span>[$_y$] = y;
      }
      get XY(){
          <span class="hljs-keyword">return</span> [<span class="hljs-keyword">super</span>[<span class="hljs-built_in">Object</span>.getOwnPropertySymbols(<span class="hljs-keyword">this</span>.__proto__.__proto__).filter(s =&gt; <span class="hljs-built_in">String</span>(s) === <span class="hljs-string">"Symbol($_X$)"</span>)[<span class="hljs-number">0</span>]], <span class="hljs-keyword">this</span>[$_y$]];
      }
    }
    <span class="hljs-keyword">return</span> Bar;
}();

<span class="hljs-keyword">let</span> bar = <span class="hljs-keyword">new</span> Bar(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-built_in">console</span>.log(bar.XY); <span class="hljs-comment">//[3, 4]</span>
</code></pre>
<p>上面的 super 里的 key 有一大串，是： </p>
<pre><code class="hljs lang-js"><span class="hljs-built_in">Object</span>.getOwnPropertySymbols(<span class="hljs-keyword">this</span>.__proto__.__proto__)
    .filter(s =&gt; <span class="hljs-built_in">String</span>(s) === <span class="hljs-string">"Symbol($_X$)"</span>)[<span class="hljs-number">0</span>]
</code></pre>
<p>这里通过 <code>Object.getOwnPropertySymbols(this.__proto__.__proto__)</code> 反射出父类的 Symbol，然后通过字符串匹配到对应的 key。</p>
<p>于是，我们确定了转换方法，那么接下来就只是实现具体的转换细节了：</p>
<pre><code class="hljs lang-js">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformCreateSymbols</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> meta = stack.pop(),
        variableNames = <span class="hljs-built_in">Array</span>.from(meta.variables);

    <span class="hljs-comment">//no private variables</span>
    <span class="hljs-keyword">if</span>(variableNames.length &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">let</span> identifiers = variableNames.map(id =&gt; t.identifier(id));

    <span class="hljs-keyword">let</span> pattern = t.arrayPattern(identifiers);

    <span class="hljs-keyword">let</span> symbols = variableNames.map(id =&gt;  
      t.callExpression(t.identifier(<span class="hljs-string">'Symbol'</span>), [t.stringLiteral(id)]));

    symbols = t.arrayExpression(symbols);

    <span class="hljs-keyword">return</span> t.variableDeclaration(
      <span class="hljs-string">'const'</span>,
      [t.variableDeclarator(pattern, symbols)]
    );  
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformWrapClass</span>(<span class="hljs-params">cls</span>)</span>{
    <span class="hljs-keyword">let</span> symbols = transformCreateSymbols();
    <span class="hljs-keyword">if</span>(!symbols) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">if</span>(cls.type === <span class="hljs-string">'ClassDeclaration'</span>){
      <span class="hljs-keyword">let</span> expr = t.callExpression(
        t.functionExpression(<span class="hljs-literal">null</span>, [], 
          t.blockStatement(
            [symbols,
             cls,
             t.returnStatement(
               t.identifier(cls.id.name)
             )]
          )
        ), []
      );

      <span class="hljs-keyword">return</span> t.variableDeclaration(
        <span class="hljs-string">'const'</span>,
        [t.variableDeclarator(
          t.identifier(cls.id.name),
          expr
        )]
      );
    }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cls.type === <span class="hljs-string">'ClassExpression'</span>){
      <span class="hljs-keyword">return</span> t.callExpression(
        t.functionExpression(<span class="hljs-literal">null</span>, [], 
          t.blockStatement(
            [symbols,
             t.returnStatement(
               cls
             )]
          )
        ), []
      );
    }
  }
</code></pre>
<p>上面的方法将 ClassDeclaration 和 ClassExpression 处理完成。接下来是处理 super 属性的部分：</p>
<pre><code class="hljs lang-js">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformPropertyToSymbol</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-keyword">let</span> expr = t.callExpression(
      t.memberExpression(
        t.identifier(<span class="hljs-string">'Object'</span>),
        t.identifier(<span class="hljs-string">'getOwnPropertySymbols'</span>)
      ), [
        t.memberExpression(
          t.memberExpression(
            t.thisExpression(),
            t.identifier(<span class="hljs-string">'__proto__'</span>)
          ),
          t.identifier(<span class="hljs-string">'__proto__'</span>)
        )
      ]
    );

    expr = t.callExpression(
      t.memberExpression(
        expr,
        t.identifier(<span class="hljs-string">'filter'</span>)
      ),
      [
        t.arrowFunctionExpression(
          [t.identifier(<span class="hljs-string">'s'</span>)],
          t.binaryExpression(
            <span class="hljs-string">'==='</span>,
            t.callExpression(
              t.identifier(<span class="hljs-string">'String'</span>),
              [t.identifier(<span class="hljs-string">'s'</span>)]
            ),
            t.stringLiteral(<span class="hljs-string">`Symbol(<span class="hljs-subst">${name}</span>)`</span>)
          )
        )
      ]
    );

    expr = t.memberExpression(
      expr,
      t.numericLiteral(<span class="hljs-number">0</span>),
      <span class="hljs-literal">true</span>
    );

    <span class="hljs-keyword">return</span> expr;
  }
</code></pre>
<p>上面代码虽然繁琐，但都并不复杂，只是 AST 树的构建而已。最终，我们形成完整的。</p>
<p>要使用的话，直接安装：</p>
<pre><code class="hljs lang-undefined">npm i babel-plugin-transform-private --save-dev
</code></pre>
<p>然后配置一下：</p>
<pre><code class="hljs lang-json">{
  <span class="hljs-attr">"plugins"</span>: [
    [<span class="hljs-string">"transform-private"</span>, {
      <span class="hljs-attr">"pattern"</span>: <span class="hljs-string">"^_"</span>
    }],
  ]
}
</code></pre>
<p>其中配置的 pattern 参数可以修改私有变量的匹配正则表达式，默认是 `&quot;^_&quot; 也就是以下划线开头，可以改成别的模式。</p>
<p>以上就是今天的全部内容，代码比较多，但是关键点就这些，其他就是构建 AST 树的过程。如有任何问题，欢迎讨论。</p>
---------------
<h1 id="#title_10" >11、How To Prototype IoT Experiences: Configuring The Software (Part 2)</h1>
Svetlin Denkov
[https://www.smashingmagazine.com/2017/04/prototype-iot-experiences-configuring-software-part-2/](https://www.smashingmagazine.com/2017/04/prototype-iot-experiences-configuring-software-part-2/)
<table width="650">
	<tr>
		<td width="650">
			<div style="width:650px;">
				<img src="http://statisches.auslieferung.commindo-media-ressourcen.de/advertisement.gif" alt="" border="0"/>
				<br/>
				<a href="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=target&collection=smashing-rss&position=1" target="_blank">
					<img src="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=image&collection=smashing-rss&position=1" border="0" alt=""/>
				</a>
				&nbsp;
				<a href="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=target&collection=smashing-rss&position=2" target="_blank">
					<img src="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=image&collection=smashing-rss&position=2" border="0" alt=""/>
				</a>
				&nbsp;
				<a href="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=target&collection=smashing-rss&position=3" target="_blank">
					<img src="http://auslieferung.commindo-media-ressourcen.de/random.php?mode=image&collection=smashing-rss&position=3" border="0" alt=""/>
				</a>
			</div>
		</td>
	</tr>
</table><p>In the first article of this series, we walked through how to put together the hardware board and all of its additional components into a single rig. I also gave you a glimpse of the decision-making process behind the selection of the board.</p>

<figure></figure>

<p>In this second (and last) article of the series, we will go over the code that will drive the sensor and the communication to the cloud. Additionally, we will configure a custom dashboard on Adafruit IO, so that we can visualize our data in real time.</p><p>The post .</p>
---------------